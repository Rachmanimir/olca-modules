<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>The openLCA core API</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="pandoc.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
    var mathElements = document.getElementsByClassName("math");
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") { katex.render(texText.data, mathElements[i], { displayMode: mathElements[i].classList.contains("display"), throwOnError: false } );
    }}});</script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">The openLCA core API</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#how-to-read-this-document">How to read this document</a></li>
<li><a href="#package-org.openlca.core.database">Package: org.openlca.core.database</a><ul>
<li><a href="#blockfetch">BlockFetch</a><ul>
<li><a href="#blockfetch-1">BlockFetch()</a></li>
<li><a href="#dofetch-listt">doFetch() : List&lt;T&gt;</a></li>
<li><a href="#dofetch-listt-1">doFetch() : List&lt;T&gt;</a></li>
</ul></li>
<li><a href="#dataproviderexception-exception">DataProviderException &gt; Exception</a><ul>
<li><a href="#dataproviderexception">DataProviderException()</a></li>
<li><a href="#dataproviderexception-1">DataProviderException()</a></li>
<li><a href="#dataproviderexception-2">DataProviderException()</a></li>
</ul></li>
<li><a href="#databaseexception-runtimeexception">DatabaseException &gt; RuntimeException</a><ul>
<li><a href="#databaseexception">DatabaseException()</a></li>
</ul></li>
<li><a href="#entitycache">EntityCache</a><ul>
<li><a href="#create-entitycache">create() : EntityCache</a></li>
<li><a href="#get-t">get() : T</a></li>
<li><a href="#getall-maplong-t">getAll() : Map&lt;Long, T&gt;</a></li>
<li><a href="#invalidate-void">invalidate() : void</a></li>
<li><a href="#invalidateall-void">invalidateAll() : void</a></li>
<li><a href="#invalidateall-void-1">invalidateAll() : void</a></li>
<li><a href="#refresh-void">refresh() : void</a></li>
</ul></li>
<li><a href="#filestore">FileStore</a><ul>
<li><a href="#filestore-1">FileStore()</a></li>
<li><a href="#filestore-2">FileStore()</a></li>
<li><a href="#copyfolder-void">copyFolder() : void</a></li>
<li><a href="#copyfolder-void-1">copyFolder() : void</a></li>
<li><a href="#copyfolder-void-2">copyFolder() : void</a></li>
<li><a href="#deletefolder-void">deleteFolder() : void</a></li>
<li><a href="#deletefolder-void-1">deleteFolder() : void</a></li>
<li><a href="#deletefolder-void-2">deleteFolder() : void</a></li>
<li><a href="#getfolder-file">getFolder() : File</a></li>
<li><a href="#getfolder-file-1">getFolder() : File</a></li>
<li><a href="#getfolder-file-2">getFolder() : File</a></li>
<li><a href="#getpath-string">getPath() : String</a></li>
<li><a href="#getpath-string-1">getPath() : String</a></li>
<li><a href="#getroot-file">getRoot() : File</a></li>
</ul></li>
<li><a href="#idatabase-closeable-inotifiable">IDatabase &gt; Closeable, INotifiable</a><ul>
<li><a href="#createconnection-connection">createConnection() : Connection</a></li>
<li><a href="#getentityfactory-entitymanagerfactory">getEntityFactory() : EntityManagerFactory</a></li>
<li><a href="#getfilestoragelocation-file">getFileStorageLocation() : File</a></li>
<li><a href="#getname-string">getName() : String</a></li>
<li><a href="#getversion-int">getVersion() : int</a></li>
</ul></li>
<li><a href="#impactmethoddao-categorizedentitydao">ImpactMethodDao &gt; CategorizedEntityDao</a><ul>
<li><a href="#impactmethoddao">ImpactMethodDao()</a></li>
<li><a href="#getcategorydescriptors-listimpactcategorydescriptor">getCategoryDescriptors() : List&lt;ImpactCategoryDescriptor&gt;</a></li>
<li><a href="#getcategorydescriptors-listimpactcategorydescriptor-1">getCategoryDescriptors() : List&lt;ImpactCategoryDescriptor&gt;</a></li>
<li><a href="#getnwsetdescriptors-listnwsetdescriptor">getNwSetDescriptors() : List&lt;NwSetDescriptor&gt;</a></li>
<li><a href="#getnwsetdescriptors-listnwsetdescriptor-1">getNwSetDescriptors() : List&lt;NwSetDescriptor&gt;</a></li>
</ul></li>
<li><a href="#query">Query</a><ul>
<li><a href="#getall-listt">getAll() : List&lt;T&gt;</a></li>
<li><a href="#getall-listt-1">getAll() : List&lt;T&gt;</a></li>
<li><a href="#getallforname-listt">getAllForName() : List&lt;T&gt;</a></li>
<li><a href="#getfirst-t">getFirst() : T</a></li>
<li><a href="#getforname-t">getForName() : T</a></li>
<li><a href="#on-query">on() : Query</a></li>
</ul></li>
</ul></li>
<li><a href="#package-org.openlca.core.database.derby">Package: org.openlca.core.database.derby</a></li>
<li><a href="#package-org.openlca.core.database.mysql">Package: org.openlca.core.database.mysql</a><ul>
<li><a href="#databasedescriptor">DatabaseDescriptor</a><ul>
<li><a href="#getname-string-1">getName() : String</a></li>
<li><a href="#getversion-int-1">getVersion() : int</a></li>
<li><a href="#isuptodate-boolean">isUpToDate() : boolean</a></li>
<li><a href="#setname-void">setName() : void</a></li>
<li><a href="#setuptodate-void">setUpToDate() : void</a></li>
<li><a href="#setversion-void">setVersion() : void</a></li>
</ul></li>
<li><a href="#mysqldatabase-notifiable-idatabase">MySQLDatabase &gt; Notifiable, IDatabase</a><ul>
<li><a href="#mysqldatabase">MySQLDatabase()</a></li>
<li><a href="#mysqldatabase-1">MySQLDatabase()</a></li>
<li><a href="#close-void">close() : void</a></li>
<li><a href="#createconnection-connection-1">createConnection() : Connection</a></li>
<li><a href="#getentityfactory-entitymanagerfactory-1">getEntityFactory() : EntityManagerFactory</a></li>
<li><a href="#getfilestoragelocation-file-1">getFileStorageLocation() : File</a></li>
<li><a href="#getname-string-2">getName() : String</a></li>
<li><a href="#getversion-int-2">getVersion() : int</a></li>
<li><a href="#setfilestoragelocation-void">setFileStorageLocation() : void</a></li>
</ul></li>
</ul></li>
<li><a href="#package-org.openlca.core.database.references">Package: org.openlca.core.database.references</a><ul>
<li><a href="#ireferencesearch">IReferenceSearch</a><ul>
<li><a href="#factory-factory">FACTORY : Factory</a></li>
<li><a href="#findreferences-listreference">findReferences() : List&lt;Reference&gt;</a></li>
<li><a href="#findreferences-listreference-1">findReferences() : List&lt;Reference&gt;</a></li>
<li><a href="#findreferences-listreference-2">findReferences() : List&lt;Reference&gt;</a></li>
<li><a href="#findreferences-listreference-3">findReferences() : List&lt;Reference&gt;</a></li>
<li><a href="#findreferences-listreference-4">findReferences() : List&lt;Reference&gt;</a></li>
</ul></li>
</ul></li>
<li><a href="#package-org.openlca.core.database.usage">Package: org.openlca.core.database.usage</a><ul>
<li><a href="#actorusesearch-baseusesearch">ActorUseSearch &gt; BaseUseSearch</a><ul>
<li><a href="#actorusesearch">ActorUseSearch()</a></li>
<li><a href="#finduses-listcategorizeddescriptor">findUses() : List&lt;CategorizedDescriptor&gt;</a></li>
</ul></li>
<li><a href="#categoryusesearch-baseusesearch">CategoryUseSearch &gt; BaseUseSearch</a><ul>
<li><a href="#categoryusesearch">CategoryUseSearch()</a></li>
<li><a href="#finduses-listcategorizeddescriptor-1">findUses() : List&lt;CategorizedDescriptor&gt;</a></li>
</ul></li>
<li><a href="#currencyusesearch-baseusesearch">CurrencyUseSearch &gt; BaseUseSearch</a><ul>
<li><a href="#currencyusesearch">CurrencyUseSearch()</a></li>
<li><a href="#finduses-listcategorizeddescriptor-2">findUses() : List&lt;CategorizedDescriptor&gt;</a></li>
</ul></li>
<li><a href="#dqsystemusesearch-baseusesearch">DQSystemUseSearch &gt; BaseUseSearch</a><ul>
<li><a href="#dqsystemusesearch">DQSystemUseSearch()</a></li>
<li><a href="#finduses-listcategorizeddescriptor-3">findUses() : List&lt;CategorizedDescriptor&gt;</a></li>
</ul></li>
<li><a href="#exchangeusesearch">ExchangeUseSearch</a><ul>
<li><a href="#exchangeusesearch-1">ExchangeUseSearch()</a></li>
<li><a href="#finduses-listcategorizeddescriptor-4">findUses() : List&lt;CategorizedDescriptor&gt;</a></li>
<li><a href="#finduses-listcategorizeddescriptor-5">findUses() : List&lt;CategorizedDescriptor&gt;</a></li>
</ul></li>
<li><a href="#flowpropertyfactorusesearch">FlowPropertyFactorUseSearch</a><ul>
<li><a href="#flowpropertyfactorusesearch-1">FlowPropertyFactorUseSearch()</a></li>
<li><a href="#finduses-listcategorizeddescriptor-6">findUses() : List&lt;CategorizedDescriptor&gt;</a></li>
</ul></li>
<li><a href="#flowpropertyusesearch-baseusesearch">FlowPropertyUseSearch &gt; BaseUseSearch</a><ul>
<li><a href="#flowpropertyusesearch">FlowPropertyUseSearch()</a></li>
<li><a href="#finduses-listcategorizeddescriptor-7">findUses() : List&lt;CategorizedDescriptor&gt;</a></li>
</ul></li>
<li><a href="#flowusesearch-baseusesearch">FlowUseSearch &gt; BaseUseSearch</a><ul>
<li><a href="#flowusesearch">FlowUseSearch()</a></li>
<li><a href="#finduses-listcategorizeddescriptor-8">findUses() : List&lt;CategorizedDescriptor&gt;</a></li>
</ul></li>
<li><a href="#iusesearch">IUseSearch</a><ul>
<li><a href="#factory-factory-1">FACTORY : Factory</a></li>
<li><a href="#finduses-listcategorizeddescriptor-9">findUses() : List&lt;CategorizedDescriptor&gt;</a></li>
<li><a href="#finduses-listcategorizeddescriptor-10">findUses() : List&lt;CategorizedDescriptor&gt;</a></li>
<li><a href="#finduses-listcategorizeddescriptor-11">findUses() : List&lt;CategorizedDescriptor&gt;</a></li>
<li><a href="#finduses-listcategorizeddescriptor-12">findUses() : List&lt;CategorizedDescriptor&gt;</a></li>
</ul></li>
<li><a href="#impactmethodusesearch-baseusesearch">ImpactMethodUseSearch &gt; BaseUseSearch</a><ul>
<li><a href="#impactmethodusesearch">ImpactMethodUseSearch()</a></li>
<li><a href="#finduses-listcategorizeddescriptor-13">findUses() : List&lt;CategorizedDescriptor&gt;</a></li>
</ul></li>
<li><a href="#locationusesearch-baseusesearch">LocationUseSearch &gt; BaseUseSearch</a><ul>
<li><a href="#locationusesearch">LocationUseSearch()</a></li>
<li><a href="#finduses-listcategorizeddescriptor-14">findUses() : List&lt;CategorizedDescriptor&gt;</a></li>
</ul></li>
<li><a href="#parameterusagetree">ParameterUsageTree</a><ul>
<li><a href="#parameterusagetree-1">ParameterUsageTree()</a></li>
<li><a href="#nodes-list">nodes : List<Node></a></li>
<li><a href="#param-string">param : String</a></li>
<li><a href="#build-parameterusagetree">build() : ParameterUsageTree</a></li>
</ul></li>
<li><a href="#parameterusesearch-baseusesearch">ParameterUseSearch &gt; BaseUseSearch</a><ul>
<li><a href="#parameterusesearch">ParameterUseSearch()</a></li>
<li><a href="#finduses-listcategorizeddescriptor-15">findUses() : List&lt;CategorizedDescriptor&gt;</a></li>
</ul></li>
<li><a href="#processusesearch-baseusesearch">ProcessUseSearch &gt; BaseUseSearch</a><ul>
<li><a href="#processusesearch">ProcessUseSearch()</a></li>
<li><a href="#finduses-listcategorizeddescriptor-16">findUses() : List&lt;CategorizedDescriptor&gt;</a></li>
</ul></li>
<li><a href="#socialindicatorusesearch-baseusesearch">SocialIndicatorUseSearch &gt; BaseUseSearch</a><ul>
<li><a href="#socialindicatorusesearch">SocialIndicatorUseSearch()</a></li>
<li><a href="#finduses-listcategorizeddescriptor-17">findUses() : List&lt;CategorizedDescriptor&gt;</a></li>
</ul></li>
<li><a href="#sourceusesearch-baseusesearch">SourceUseSearch &gt; BaseUseSearch</a><ul>
<li><a href="#sourceusesearch">SourceUseSearch()</a></li>
<li><a href="#finduses-listcategorizeddescriptor-18">findUses() : List&lt;CategorizedDescriptor&gt;</a></li>
</ul></li>
<li><a href="#unitgroupusesearch-baseusesearch">UnitGroupUseSearch &gt; BaseUseSearch</a><ul>
<li><a href="#unitgroupusesearch">UnitGroupUseSearch()</a></li>
<li><a href="#finduses-listcategorizeddescriptor-19">findUses() : List&lt;CategorizedDescriptor&gt;</a></li>
</ul></li>
<li><a href="#unitusesearch">UnitUseSearch</a><ul>
<li><a href="#unitusesearch-1">UnitUseSearch()</a></li>
<li><a href="#finduses-listcategorizeddescriptor-20">findUses() : List&lt;CategorizedDescriptor&gt;</a></li>
</ul></li>
</ul></li>
<li><a href="#package-org.openlca.core.math">Package: org.openlca.core.math</a><ul>
<li><a href="#calculationsetup">CalculationSetup</a><ul>
<li><a href="#calculationsetup-1">CalculationSetup()</a></li>
<li><a href="#allocationmethod-allocationmethod">allocationMethod : AllocationMethod</a></li>
<li><a href="#impactmethod-impactmethoddescriptor">impactMethod : ImpactMethodDescriptor</a></li>
<li><a href="#numberofruns-int">numberOfRuns : int</a></li>
<li><a href="#nwset-nwsetdescriptor">nwSet : NwSetDescriptor</a></li>
<li><a href="#parameterredefs-list">parameterRedefs : List<ParameterRedef></a></li>
<li><a href="#productsystem-productsystem">productSystem : ProductSystem</a></li>
<li><a href="#type-calculationtype">type : CalculationType</a></li>
<li><a href="#withcosts-boolean">withCosts : boolean</a></li>
<li><a href="#getamount-double">getAmount() : double</a></li>
<li><a href="#getflowpropertyfactor-flowpropertyfactor">getFlowPropertyFactor() : FlowPropertyFactor</a></li>
<li><a href="#getunit-unit">getUnit() : Unit</a></li>
<li><a href="#setamount-void">setAmount() : void</a></li>
<li><a href="#setflowpropertyfactor-void">setFlowPropertyFactor() : void</a></li>
<li><a href="#setunit-void">setUnit() : void</a></li>
</ul></li>
<li><a href="#calculationtype">CalculationType</a><ul>
<li><a href="#simple_calculation">SIMPLE_CALCULATION</a></li>
<li><a href="#contribution_analysis">CONTRIBUTION_ANALYSIS</a></li>
<li><a href="#upstream_analysis">UPSTREAM_ANALYSIS</a></li>
<li><a href="#regionalized_calculation">REGIONALIZED_CALCULATION</a></li>
<li><a href="#monte_carlo_simulation">MONTE_CARLO_SIMULATION</a></li>
</ul></li>
<li><a href="#datastructures">DataStructures</a><ul>
<li><a href="#createproductindex-techindex">createProductIndex() : TechIndex</a></li>
<li><a href="#interpreter-formulainterpreter">interpreter() : FormulaInterpreter</a></li>
<li><a href="#matrixdata-matrixdata">matrixData() : MatrixData</a></li>
<li><a href="#parametercontexts-setlong">parameterContexts() : Set&lt;Long&gt;</a></li>
</ul></li>
<li><a href="#lcacalculator">LcaCalculator</a><ul>
<li><a href="#lcacalculator-1">LcaCalculator()</a></li>
<li><a href="#calculatecontributions-contributionresult">calculateContributions() : ContributionResult</a></li>
<li><a href="#calculatefull-fullresult">calculateFull() : FullResult</a></li>
<li><a href="#calculatesimple-simpleresult">calculateSimple() : SimpleResult</a></li>
<li><a href="#getloopfactor-double">getLoopFactor() : double</a></li>
<li><a href="#getrealdemands-double">getRealDemands() : double[]</a></li>
<li><a href="#getscalingvector-double">getScalingVector() : double[]</a></li>
<li><a href="#gettotalrequirements-double">getTotalRequirements() : double[]</a></li>
</ul></li>
<li><a href="#matrixrowsorter">MatrixRowSorter</a><ul>
<li><a href="#matrixrowsorter-1">MatrixRowSorter()</a></li>
<li><a href="#run-imatrix">run() : IMatrix</a></li>
</ul></li>
<li><a href="#referenceamount">ReferenceAmount</a><ul>
<li><a href="#get-double">get() : double</a></li>
<li><a href="#get-double-1">get() : double</a></li>
<li><a href="#get-double-2">get() : double</a></li>
</ul></li>
<li><a href="#simulator">Simulator</a><ul>
<li><a href="#pinnedproducts-set">pinnedProducts : Set<ProcessProduct></a></li>
<li><a href="#create-simulator">create() : Simulator</a></li>
<li><a href="#getenviindex-flowindex">getEnviIndex() : FlowIndex</a></li>
<li><a href="#getimpactindex-dindeximpactcategorydescriptor">getImpactIndex() : DIndex&lt;ImpactCategoryDescriptor&gt;</a></li>
<li><a href="#getresult-simulationresult">getResult() : SimulationResult</a></li>
<li><a href="#gettechindex-techindex">getTechIndex() : TechIndex</a></li>
<li><a href="#nextrun-simpleresult">nextRun() : SimpleResult</a></li>
</ul></li>
<li><a href="#systemcalculator">SystemCalculator</a><ul>
<li><a href="#systemcalculator-1">SystemCalculator()</a></li>
<li><a href="#calculate-projectresult">calculate() : ProjectResult</a></li>
<li><a href="#calculatecontributions-contributionresult-1">calculateContributions() : ContributionResult</a></li>
<li><a href="#calculatefull-fullresult-1">calculateFull() : FullResult</a></li>
<li><a href="#calculatesimple-simpleresult-1">calculateSimple() : SimpleResult</a></li>
</ul></li>
</ul></li>
<li><a href="#package-org.openlca.core.math.data_quality">Package: org.openlca.core.math.data_quality</a><ul>
<li><a href="#processingtype">ProcessingType</a><ul>
<li><a href="#exclude">EXCLUDE</a></li>
<li><a href="#use_max">USE_MAX</a></li>
</ul></li>
</ul></li>
<li><a href="#package-org.openlca.core.matrix">Package: org.openlca.core.matrix</a><ul>
<li><a href="#allocationindex">AllocationIndex</a><ul>
<li><a href="#create-allocationindex">create() : AllocationIndex</a></li>
<li><a href="#get-double-3">get() : double</a></li>
</ul></li>
<li><a href="#costvector">CostVector</a><ul>
<li><a href="#asmatrix-imatrix">asMatrix() : IMatrix</a></li>
</ul></li>
<li><a href="#dindex">DIndex</a><ul>
<li><a href="#at-d">at() : D</a></li>
<li><a href="#contains-boolean">contains() : boolean</a></li>
<li><a href="#contains-boolean-1">contains() : boolean</a></li>
<li><a href="#content-setd">content() : Set&lt;D&gt;</a></li>
<li><a href="#each-void">each() : void</a></li>
<li><a href="#idat-long">idAt() : long</a></li>
<li><a href="#ids-long">ids() : long[]</a></li>
<li><a href="#isempty-boolean">isEmpty() : boolean</a></li>
<li><a href="#of-int">of() : int</a></li>
<li><a href="#of-int-1">of() : int</a></li>
<li><a href="#put-int">put() : int</a></li>
<li><a href="#putall-void">putAll() : void</a></li>
<li><a href="#size-int">size() : int</a></li>
</ul></li>
<li><a href="#fastmatrixbuilder">FastMatrixBuilder</a><ul>
<li><a href="#fastmatrixbuilder-1">FastMatrixBuilder()</a></li>
<li><a href="#build-matrixdata">build() : MatrixData</a></li>
</ul></li>
<li><a href="#flowindex-dindex">FlowIndex &gt; DIndex</a><ul>
<li><a href="#build-flowindex">build() : FlowIndex</a></li>
<li><a href="#isinput-boolean">isInput() : boolean</a></li>
<li><a href="#isinput-boolean-1">isInput() : boolean</a></li>
<li><a href="#putinput-int">putInput() : int</a></li>
<li><a href="#putoutput-int">putOutput() : int</a></li>
</ul></li>
<li><a href="#impactfactormatrix">ImpactFactorMatrix</a><ul>
<li><a href="#impactfactormatrix-1">ImpactFactorMatrix()</a></li>
<li><a href="#apply-void">apply() : void</a></li>
<li><a href="#createrealmatrix-imatrix">createRealMatrix() : IMatrix</a></li>
<li><a href="#getentry-impactfactorcell">getEntry() : ImpactFactorCell</a></li>
<li><a href="#isempty-boolean-1">isEmpty() : boolean</a></li>
<li><a href="#setentry-void">setEntry() : void</a></li>
<li><a href="#simulate-void">simulate() : void</a></li>
</ul></li>
<li><a href="#impacttable">ImpactTable</a><ul>
<li><a href="#factormatrix-impactfactormatrix">factorMatrix : ImpactFactorMatrix</a></li>
<li><a href="#flowindex-flowindex">flowIndex : FlowIndex</a></li>
<li><a href="#impactindex-dindex">impactIndex : DIndex<ImpactCategoryDescriptor></a></li>
<li><a href="#build-impacttable">build() : ImpactTable</a></li>
<li><a href="#creatematrix-imatrix">createMatrix() : IMatrix</a></li>
<li><a href="#creatematrix-imatrix-1">createMatrix() : IMatrix</a></li>
<li><a href="#isempty-boolean-2">isEmpty() : boolean</a></li>
<li><a href="#simulate-void-1">simulate() : void</a></li>
</ul></li>
<li><a href="#indexconsumer">IndexConsumer</a><ul>
<li><a href="#accept-void">accept() : void</a></li>
</ul></li>
<li><a href="#inventoryconfig">InventoryConfig</a><ul>
<li><a href="#inventoryconfig-1">InventoryConfig()</a></li>
<li><a href="#allocationmethod-allocationmethod-1">allocationMethod : AllocationMethod</a></li>
<li><a href="#db-idatabase">db : IDatabase</a></li>
<li><a href="#interpreter-formulainterpreter-1">interpreter : FormulaInterpreter</a></li>
<li><a href="#subresults-mapprocessproductsimpleresult">subResults : Map&lt;ProcessProduct,SimpleResult&gt;</a></li>
<li><a href="#techindex-techindex">techIndex : TechIndex</a></li>
<li><a href="#withcosts-boolean-1">withCosts : boolean</a></li>
<li><a href="#withuncertainties-boolean">withUncertainties : boolean</a></li>
</ul></li>
<li><a href="#linkingcallback">LinkingCallback</a><ul>
<li><a href="#cancel-boolean">cancel() : boolean</a></li>
<li><a href="#select-listprocessproduct">select() : List&lt;ProcessProduct&gt;</a></li>
</ul></li>
<li><a href="#longindex">LongIndex</a><ul>
<li><a href="#contains-boolean-2">contains() : boolean</a></li>
<li><a href="#getindex-int">getIndex() : int</a></li>
<li><a href="#getkeyat-long">getKeyAt() : long</a></li>
<li><a href="#getkeys-long">getKeys() : long[]</a></li>
<li><a href="#isempty-boolean-3">isEmpty() : boolean</a></li>
<li><a href="#put-int-1">put() : int</a></li>
<li><a href="#size-int-1">size() : int</a></li>
</ul></li>
<li><a href="#longpair-comparable">LongPair &gt; Comparable</a><ul>
<li><a href="#longpair">LongPair()</a></li>
<li><a href="#first-long">first : long</a></li>
<li><a href="#second-long">second : long</a></li>
<li><a href="#compareto-int">compareTo() : int</a></li>
<li><a href="#equals-boolean">equals() : boolean</a></li>
<li><a href="#equals-boolean-1">equals() : boolean</a></li>
<li><a href="#hashcode-int">hashCode() : int</a></li>
<li><a href="#of-longpair">of() : LongPair</a></li>
<li><a href="#tostring-string">toString() : String</a></li>
</ul></li>
<li><a href="#matrixdata">MatrixData</a><ul>
<li><a href="#costvector-double">costVector : double[]</a></li>
<li><a href="#enviindex-flowindex">enviIndex : FlowIndex</a></li>
<li><a href="#envimatrix-imatrix">enviMatrix : IMatrix</a></li>
<li><a href="#enviuncertainties-umatrix">enviUncertainties : UMatrix</a></li>
<li><a href="#impactindex-dindex-1">impactIndex : DIndex<ImpactCategoryDescriptor></a></li>
<li><a href="#impactmatrix-imatrix">impactMatrix : IMatrix</a></li>
<li><a href="#techindex-techindex-1">techIndex : TechIndex</a></li>
<li><a href="#techmatrix-imatrix">techMatrix : IMatrix</a></li>
<li><a href="#techuncertainties-umatrix">techUncertainties : UMatrix</a></li>
<li><a href="#simulate-void-2">simulate() : void</a></li>
</ul></li>
<li><a href="#nwsettable">NwSetTable</a><ul>
<li><a href="#applyboth-listimpactresult">applyBoth() : List&lt;ImpactResult&gt;</a></li>
<li><a href="#applynormalisation-listimpactresult">applyNormalisation() : List&lt;ImpactResult&gt;</a></li>
<li><a href="#applyweighting-listimpactresult">applyWeighting() : List&lt;ImpactResult&gt;</a></li>
<li><a href="#build-nwsettable">build() : NwSetTable</a></li>
<li><a href="#getnormalisationfactor-double">getNormalisationFactor() : double</a></li>
<li><a href="#getweightingfactor-double">getWeightingFactor() : double</a></li>
<li><a href="#hasnormalisationfactors-boolean">hasNormalisationFactors() : boolean</a></li>
<li><a href="#hasweightingfactors-boolean">hasWeightingFactors() : boolean</a></li>
</ul></li>
<li><a href="#parametertable">ParameterTable</a><ul>
<li><a href="#forsimulation-parametertable">forSimulation() : ParameterTable</a></li>
<li><a href="#interpreter-formulainterpreter-2">interpreter() : FormulaInterpreter</a></li>
<li><a href="#simulate-formulainterpreter">simulate() : FormulaInterpreter</a></li>
</ul></li>
<li><a href="#processlinksearchmap">ProcessLinkSearchMap</a><ul>
<li><a href="#processlinksearchmap-1">ProcessLinkSearchMap()</a></li>
<li><a href="#getincominglinks-listprocesslink">getIncomingLinks() : List&lt;ProcessLink&gt;</a></li>
<li><a href="#getlinks-listprocesslink">getLinks() : List&lt;ProcessLink&gt;</a></li>
<li><a href="#getoutgoinglinks-listprocesslink">getOutgoingLinks() : List&lt;ProcessLink&gt;</a></li>
</ul></li>
<li><a href="#processproduct">ProcessProduct</a><ul>
<li><a href="#flow-flowdescriptor">flow : FlowDescriptor</a></li>
<li><a href="#process-categorizeddescriptor">process : CategorizedDescriptor</a></li>
<li><a href="#equals-boolean-2">equals() : boolean</a></li>
<li><a href="#flowid-long">flowId() : long</a></li>
<li><a href="#hashcode-int-1">hashCode() : int</a></li>
<li><a href="#id-long">id() : long</a></li>
<li><a href="#locationid-long">locationId() : Long</a></li>
<li><a href="#of-processproduct">of() : ProcessProduct</a></li>
<li><a href="#of-processproduct-1">of() : ProcessProduct</a></li>
<li><a href="#of-processproduct-2">of() : ProcessProduct</a></li>
<li><a href="#pair-longpair">pair() : LongPair</a></li>
</ul></li>
<li><a href="#productsystembuilder">ProductSystemBuilder</a><ul>
<li><a href="#productsystembuilder-1">ProductSystemBuilder()</a></li>
<li><a href="#autocomplete-void">autoComplete() : void</a></li>
<li><a href="#autocomplete-void-1">autoComplete() : void</a></li>
<li><a href="#build-productsystem">build() : ProductSystem</a></li>
<li><a href="#saveupdates-productsystem">saveUpdates() : ProductSystem</a></li>
</ul></li>
<li><a href="#techindex">TechIndex</a><ul>
<li><a href="#techindex-1">TechIndex()</a></li>
<li><a href="#contains-boolean-3">contains() : boolean</a></li>
<li><a href="#content-setprocessproduct">content() : Set&lt;ProcessProduct&gt;</a></li>
<li><a href="#each-void-1">each() : void</a></li>
<li><a href="#getdemand-double">getDemand() : double</a></li>
<li><a href="#getindex-int-1">getIndex() : int</a></li>
<li><a href="#getlinkedexchanges-setlongpair">getLinkedExchanges() : Set&lt;LongPair&gt;</a></li>
<li><a href="#getlinkedprovider-processproduct">getLinkedProvider() : ProcessProduct</a></li>
<li><a href="#getprocessids-setlong">getProcessIds() : Set&lt;Long&gt;</a></li>
<li><a href="#getprovider-processproduct">getProvider() : ProcessProduct</a></li>
<li><a href="#getproviderat-processproduct">getProviderAt() : ProcessProduct</a></li>
<li><a href="#getproviders-listprocessproduct">getProviders() : List&lt;ProcessProduct&gt;</a></li>
<li><a href="#getproviders-listprocessproduct-1">getProviders() : List&lt;ProcessProduct&gt;</a></li>
<li><a href="#getrefflow-processproduct">getRefFlow() : ProcessProduct</a></li>
<li><a href="#islinked-boolean">isLinked() : boolean</a></li>
<li><a href="#isprovider-boolean">isProvider() : boolean</a></li>
<li><a href="#put-void">put() : void</a></li>
<li><a href="#putlink-void">putLink() : void</a></li>
<li><a href="#setdemand-void">setDemand() : void</a></li>
<li><a href="#size-int-2">size() : int</a></li>
</ul></li>
<li><a href="#umatrix">UMatrix</a><ul>
<li><a href="#umatrix-1">UMatrix()</a></li>
<li><a href="#add-void">add() : void</a></li>
<li><a href="#generate-void">generate() : void</a></li>
</ul></li>
</ul></li>
<li><a href="#package-org.openlca.core.matrix.cache">Package: org.openlca.core.matrix.cache</a><ul>
<li><a href="#conversiontable">ConversionTable</a><ul>
<li><a href="#create-conversiontable">create() : ConversionTable</a></li>
<li><a href="#getcurrencyfactor-double">getCurrencyFactor() : double</a></li>
<li><a href="#getpropertyfactor-double">getPropertyFactor() : double</a></li>
<li><a href="#getunitfactor-double">getUnitFactor() : double</a></li>
<li><a href="#reload-void">reload() : void</a></li>
</ul></li>
<li><a href="#flowtable">FlowTable</a><ul>
<li><a href="#create-flowtable">create() : FlowTable</a></li>
<li><a href="#get-flowdescriptor">get() : FlowDescriptor</a></li>
<li><a href="#getflowids-long">getFlowIds() : long[]</a></li>
<li><a href="#gettypes-tlongobjecthashmapflowtype">getTypes() : TLongObjectHashMap&lt;FlowType&gt;</a></li>
<li><a href="#reload-void-1">reload() : void</a></li>
<li><a href="#type-flowtype">type() : FlowType</a></li>
</ul></li>
<li><a href="#processtable">ProcessTable</a><ul>
<li><a href="#create-processtable">create() : ProcessTable</a></li>
<li><a href="#getprovider-processproduct-1">getProvider() : ProcessProduct</a></li>
<li><a href="#getproviders-listprocessproduct-2">getProviders() : List&lt;ProcessProduct&gt;</a></li>
<li><a href="#getproviders-listprocessproduct-3">getProviders() : List&lt;ProcessProduct&gt;</a></li>
<li><a href="#gettype-processtype">getType() : ProcessType</a></li>
</ul></li>
</ul></li>
<li><a href="#package-org.openlca.core.matrix.format">Package: org.openlca.core.matrix.format</a><ul>
<li><a href="#ccrmatrix-imatrix">CCRMatrix &gt; IMatrix</a><ul>
<li><a href="#columnpointers-int">columnPointers : int[]</a></li>
<li><a href="#columns-int">columns : int</a></li>
<li><a href="#rowindices-int">rowIndices : int[]</a></li>
<li><a href="#rows-int">rows : int</a></li>
<li><a href="#values-double">values : double[]</a></li>
<li><a href="#columns-int-1">columns() : int</a></li>
<li><a href="#copy-imatrix">copy() : IMatrix</a></li>
<li><a href="#get-double-4">get() : double</a></li>
<li><a href="#getcolumn-double">getColumn() : double[]</a></li>
<li><a href="#getrow-double">getRow() : double[]</a></li>
<li><a href="#of-ccrmatrix">of() : CCRMatrix</a></li>
<li><a href="#rows-int-1">rows() : int</a></li>
<li><a href="#set-void">set() : void</a></li>
<li><a href="#setvalues-void">setValues() : void</a></li>
</ul></li>
<li><a href="#densematrix-imatrix">DenseMatrix &gt; IMatrix</a><ul>
<li><a href="#densematrix">DenseMatrix()</a></li>
<li><a href="#columns-int-2">columns() : int</a></li>
<li><a href="#copy-densematrix">copy() : DenseMatrix</a></li>
<li><a href="#get-double-5">get() : double</a></li>
<li><a href="#getcolumn-double-1">getColumn() : double[]</a></li>
<li><a href="#getdata-double">getData() : double[]</a></li>
<li><a href="#getrow-double-1">getRow() : double[]</a></li>
<li><a href="#rows-int-2">rows() : int</a></li>
<li><a href="#set-void-1">set() : void</a></li>
</ul></li>
<li><a href="#hashpointmatrix-imatrix">HashPointMatrix &gt; IMatrix</a><ul>
<li><a href="#hashpointmatrix">HashPointMatrix()</a></li>
<li><a href="#hashpointmatrix-1">HashPointMatrix()</a></li>
<li><a href="#hashpointmatrix-2">HashPointMatrix()</a></li>
<li><a href="#cols-int">cols : int</a></li>
<li><a href="#rows-int-3">rows : int</a></li>
<li><a href="#clear-void">clear() : void</a></li>
<li><a href="#columns-int-3">columns() : int</a></li>
<li><a href="#compress-compressedrowmatrix">compress() : CompressedRowMatrix</a></li>
<li><a href="#copy-hashpointmatrix">copy() : HashPointMatrix</a></li>
<li><a href="#get-double-6">get() : double</a></li>
<li><a href="#getcolumn-double-2">getColumn() : double[]</a></li>
<li><a href="#getnumberofentries-int">getNumberOfEntries() : int</a></li>
<li><a href="#getrow-double-2">getRow() : double[]</a></li>
<li><a href="#iterate-void">iterate() : void</a></li>
<li><a href="#multiply-double">multiply() : double[]</a></li>
<li><a href="#rows-int-4">rows() : int</a></li>
<li><a href="#scalecolumns-void">scaleColumns() : void</a></li>
<li><a href="#set-void-2">set() : void</a></li>
<li><a href="#tostring-string-1">toString() : String</a></li>
</ul></li>
<li><a href="#imatrix">IMatrix</a><ul>
<li><a href="#columns-int-4">columns() : int</a></li>
<li><a href="#copy-imatrix-1">copy() : IMatrix</a></li>
<li><a href="#get-double-7">get() : double</a></li>
<li><a href="#getcolumn-double-3">getColumn() : double[]</a></li>
<li><a href="#getrow-double-3">getRow() : double[]</a></li>
<li><a href="#rows-int-5">rows() : int</a></li>
<li><a href="#set-void-3">set() : void</a></li>
<li><a href="#setvalues-void-1">setValues() : void</a></li>
</ul></li>
<li><a href="#matrixbuilder">MatrixBuilder</a><ul>
<li><a href="#matrixbuilder-1">MatrixBuilder()</a></li>
<li><a href="#matrixbuilder-2">MatrixBuilder()</a></li>
<li><a href="#matrixbuilder-3">MatrixBuilder()</a></li>
<li><a href="#add-void-1">add() : void</a></li>
<li><a href="#finish-imatrix">finish() : IMatrix</a></li>
<li><a href="#minsize-void">minSize() : void</a></li>
<li><a href="#set-void-4">set() : void</a></li>
</ul></li>
<li><a href="#sparsematrixdata-serializable">SparseMatrixData &gt; Serializable</a><ul>
<li><a href="#sparsematrixdata">SparseMatrixData()</a></li>
<li><a href="#sparsematrixdata-1">SparseMatrixData()</a></li>
<li><a href="#columnindices-int">columnIndices : int[]</a></li>
<li><a href="#columns-int-5">columns : int</a></li>
<li><a href="#numberofentries-int">numberOfEntries : int</a></li>
<li><a href="#rowindices-int-1">rowIndices : int[]</a></li>
<li><a href="#rows-int-6">rows : int</a></li>
<li><a href="#values-double-1">values : double[]</a></li>
</ul></li>
</ul></li>
<li><a href="#package-org.openlca.core.matrix.io">Package: org.openlca.core.matrix.io</a><ul>
<li><a href="#csvout">CsvOut</a><ul>
<li><a href="#write-void">write() : void</a></li>
<li><a href="#write-void-1">write() : void</a></li>
<li><a href="#write-void-2">write() : void</a></li>
<li><a href="#write-void-3">write() : void</a></li>
<li><a href="#write-void-4">write() : void</a></li>
<li><a href="#write-void-5">write() : void</a></li>
<li><a href="#writecol-void">writeCol() : void</a></li>
</ul></li>
<li><a href="#marketformatwriter">MarketFormatWriter</a><ul>
<li><a href="#marketformatwriter-1">MarketFormatWriter()</a></li>
<li><a href="#writedense-void">writeDense() : void</a></li>
<li><a href="#writesparse-void">writeSparse() : void</a></li>
</ul></li>
<li><a href="#matbinmatrixreader">MatBinMatrixReader</a><ul>
<li><a href="#matbinmatrixreader-1">MatBinMatrixReader()</a></li>
<li><a href="#read-imatrix">read() : IMatrix</a></li>
<li><a href="#setusestreaming-void">setUseStreaming() : void</a></li>
</ul></li>
</ul></li>
<li><a href="#package-org.openlca.core.matrix.io.olcamat">Package: org.openlca.core.matrix.io.olcamat</a><ul>
<li><a href="#enviindexentry">EnviIndexEntry</a><ul>
<li><a href="#flowcategory-string">flowCategory : String</a></li>
<li><a href="#flowid-string">flowID : String</a></li>
<li><a href="#flowlocation-string">flowLocation : String</a></li>
<li><a href="#flowname-string">flowName : String</a></li>
<li><a href="#flowpropertyid-string">flowPropertyID : String</a></li>
<li><a href="#flowpropertyname-string">flowPropertyName : String</a></li>
<li><a href="#flowtype-flowtype">flowType : FlowType</a></li>
<li><a href="#index-int">index : int</a></li>
<li><a href="#unitid-string">unitID : String</a></li>
<li><a href="#unitname-string">unitName : String</a></li>
<li><a href="#clone-enviindexentry">clone() : EnviIndexEntry</a></li>
</ul></li>
<li><a href="#export-runnable">Export &gt; Runnable</a><ul>
<li><a href="#export">Export()</a></li>
<li><a href="#export-1">Export()</a></li>
<li><a href="#withresults-boolean">withResults : boolean</a></li>
<li><a href="#run-void">run() : void</a></li>
</ul></li>
<li><a href="#techindexentry-enviindexentry">TechIndexEntry &gt; EnviIndexEntry</a><ul>
<li><a href="#processcategory-string">processCategory : String</a></li>
<li><a href="#processid-string">processID : String</a></li>
<li><a href="#processlocation-string">processLocation : String</a></li>
<li><a href="#processname-string">processName : String</a></li>
<li><a href="#processtype-processtype">processType : ProcessType</a></li>
<li><a href="#clone-techindexentry">clone() : TechIndexEntry</a></li>
</ul></li>
</ul></li>
<li><a href="#package-org.openlca.core.matrix.product.index">Package: org.openlca.core.matrix.product.index</a><ul>
<li><a href="#providersearch">ProviderSearch</a><ul>
<li><a href="#providersearch-1">ProviderSearch()</a></li>
<li><a href="#find-processproduct">find() : ProcessProduct</a></li>
<li><a href="#getlinkcandidates-listcalcexchange">getLinkCandidates() : List&lt;CalcExchange&gt;</a></li>
</ul></li>
</ul></li>
<li><a href="#package-org.openlca.core.matrix.solvers">Package: org.openlca.core.matrix.solvers</a><ul>
<li><a href="#densesolver-imatrixsolver">DenseSolver &gt; IMatrixSolver</a><ul>
<li><a href="#invert-densematrix">invert() : DenseMatrix</a></li>
<li><a href="#matrix-imatrix">matrix() : IMatrix</a></li>
<li><a href="#multiply-double-1">multiply() : double[]</a></li>
<li><a href="#multiply-densematrix">multiply() : DenseMatrix</a></li>
<li><a href="#scalecolumns-void-1">scaleColumns() : void</a></li>
<li><a href="#solve-double">solve() : double[]</a></li>
</ul></li>
<li><a href="#imatrixsolver">IMatrixSolver</a><ul>
<li><a href="#invert-imatrix">invert() : IMatrix</a></li>
<li><a href="#matrix-imatrix-1">matrix() : IMatrix</a></li>
<li><a href="#matrix-imatrix-2">matrix() : IMatrix</a></li>
<li><a href="#multiply-imatrix">multiply() : IMatrix</a></li>
<li><a href="#multiply-double-2">multiply() : double[]</a></li>
<li><a href="#scalecolumns-void-2">scaleColumns() : void</a></li>
<li><a href="#solve-double-1">solve() : double[]</a></li>
</ul></li>
</ul></li>
<li><a href="#package-org.openlca.core.model">Package: org.openlca.core.model</a><ul>
<li><a href="#abstractentity">AbstractEntity</a><ul>
<li><a href="#id-long-1">id : long</a></li>
<li><a href="#equals-boolean-3">equals() : boolean</a></li>
<li><a href="#hashcode-int-2">hashCode() : int</a></li>
<li><a href="#tostring-string-2">toString() : String</a></li>
</ul></li>
<li><a href="#actor-categorizedentity">Actor &gt; CategorizedEntity</a><ul>
<li><a href="#address-string">address : String</a></li>
<li><a href="#city-string">city : String</a></li>
<li><a href="#country-string">country : String</a></li>
<li><a href="#email-string">email : String</a></li>
<li><a href="#telefax-string">telefax : String</a></li>
<li><a href="#telephone-string">telephone : String</a></li>
<li><a href="#website-string">website : String</a></li>
<li><a href="#zipcode-string">zipCode : String</a></li>
<li><a href="#clone-actor">clone() : Actor</a></li>
</ul></li>
<li><a href="#allocationfactor-abstractentity-cloneable">AllocationFactor &gt; AbstractEntity, Cloneable</a><ul>
<li><a href="#exchange-exchange">exchange : Exchange</a></li>
<li><a href="#method-allocationmethod">method : AllocationMethod</a></li>
<li><a href="#productid-long">productId : long</a></li>
<li><a href="#value-double">value : double</a></li>
<li><a href="#clone-allocationfactor">clone() : AllocationFactor</a></li>
</ul></li>
<li><a href="#allocationmethod">AllocationMethod</a><ul>
<li><a href="#use_default">USE_DEFAULT</a></li>
<li><a href="#causal">CAUSAL</a></li>
<li><a href="#economic">ECONOMIC</a></li>
<li><a href="#none">NONE</a></li>
<li><a href="#physical">PHYSICAL</a></li>
</ul></li>
<li><a href="#callback">Callback</a><ul>
<li><a href="#apply-void-1">apply() : void</a></li>
</ul></li>
<li><a href="#categorizedentity-rootentity">CategorizedEntity &gt; RootEntity</a><ul>
<li><a href="#category-category">category : Category</a></li>
</ul></li>
<li><a href="#exchange-abstractentity">Exchange &gt; AbstractEntity</a><ul>
<li><a href="#amount-double">amount : double</a></li>
<li><a href="#amountformula-string">amountFormula : String</a></li>
<li><a href="#baseuncertainty-double">baseUncertainty : Double</a></li>
<li><a href="#costformula-string">costFormula : String</a></li>
<li><a href="#costs-double">costs : Double</a></li>
<li><a href="#currency-currency">currency : Currency</a></li>
<li><a href="#defaultproviderid-long">defaultProviderId : long</a></li>
<li><a href="#description-string">description : String</a></li>
<li><a href="#dqentry-string">dqEntry : String</a></li>
<li><a href="#flow-flow">flow : Flow</a></li>
<li><a href="#flowpropertyfactor-flowpropertyfactor">flowPropertyFactor : FlowPropertyFactor</a></li>
<li><a href="#internalid-int">internalId : int</a></li>
<li><a href="#isavoided-boolean">isAvoided : boolean</a></li>
<li><a href="#isinput-boolean-2">isInput : boolean</a></li>
<li><a href="#uncertainty-uncertainty">uncertainty : Uncertainty</a></li>
<li><a href="#unit-unit">unit : Unit</a></li>
<li><a href="#clone-exchange">clone() : Exchange</a></li>
<li><a href="#from-exchange">from() : Exchange</a></li>
<li><a href="#from-exchange-1">from() : Exchange</a></li>
<li><a href="#tostring-string-3">toString() : String</a></li>
</ul></li>
<li><a href="#flowproperty-categorizedentity">FlowProperty &gt; CategorizedEntity</a><ul>
<li><a href="#flowpropertytype-flowpropertytype">flowPropertyType : FlowPropertyType</a></li>
<li><a href="#unitgroup-unitgroup">unitGroup : UnitGroup</a></li>
<li><a href="#clone-flowproperty">clone() : FlowProperty</a></li>
</ul></li>
<li><a href="#flowpropertyfactor-abstractentity">FlowPropertyFactor &gt; AbstractEntity</a><ul>
<li><a href="#conversionfactor-double">conversionFactor : double</a></li>
<li><a href="#flowproperty-flowproperty">flowProperty : FlowProperty</a></li>
<li><a href="#clone-flowpropertyfactor">clone() : FlowPropertyFactor</a></li>
</ul></li>
<li><a href="#flowtype">FlowType</a><ul>
<li><a href="#elementary_flow">ELEMENTARY_FLOW</a></li>
<li><a href="#product_flow">PRODUCT_FLOW</a></li>
<li><a href="#waste_flow">WASTE_FLOW</a></li>
</ul></li>
<li><a href="#mappingfile-abstractentity">MappingFile &gt; AbstractEntity</a><ul>
<li><a href="#content-byte">content : byte[]</a></li>
<li><a href="#filename-string">fileName : String</a></li>
</ul></li>
<li><a href="#modeltype">ModelType</a><ul>
<li><a href="#unknown">UNKNOWN</a></li>
<li><a href="#project">PROJECT</a></li>
<li><a href="#impact_method">IMPACT_METHOD</a></li>
<li><a href="#impact_category">IMPACT_CATEGORY</a></li>
<li><a href="#product_system">PRODUCT_SYSTEM</a></li>
<li><a href="#process">PROCESS</a></li>
<li><a href="#flow">FLOW</a></li>
<li><a href="#flow_property">FLOW_PROPERTY</a></li>
<li><a href="#unit_group">UNIT_GROUP</a></li>
<li><a href="#unit">UNIT</a></li>
<li><a href="#actor">ACTOR</a></li>
<li><a href="#source">SOURCE</a></li>
<li><a href="#category">CATEGORY</a></li>
<li><a href="#location">LOCATION</a></li>
<li><a href="#nw_set">NW_SET</a></li>
<li><a href="#social_indicator">SOCIAL_INDICATOR</a></li>
<li><a href="#currency">CURRENCY</a></li>
<li><a href="#parameter">PARAMETER</a></li>
<li><a href="#dq_system">DQ_SYSTEM</a></li>
<li><a href="#categorized-modeltype">categorized() : ModelType[]</a></li>
<li><a href="#formodelclass-modeltype">forModelClass() : ModelType</a></li>
<li><a href="#getmodelclass-class-extends-rootentity">getModelClass() : Class&lt;? extends RootEntity&gt;</a></li>
<li><a href="#iscategorized-boolean">isCategorized() : boolean</a></li>
<li><a href="#isoneof-boolean">isOneOf() : boolean</a></li>
</ul></li>
<li><a href="#nwset-rootentity">NwSet &gt; RootEntity</a><ul>
<li><a href="#factors-list">factors : List<NwFactor></a></li>
<li><a href="#weightedscoreunit-string">weightedScoreUnit : String</a></li>
<li><a href="#clone-nwset">clone() : NwSet</a></li>
<li><a href="#getfactor-nwfactor">getFactor() : NwFactor</a></li>
</ul></li>
<li><a href="#parameter-categorizedentity">Parameter &gt; CategorizedEntity</a><ul>
<li><a href="#externalsource-string">externalSource : String</a></li>
<li><a href="#formula-string">formula : String</a></li>
<li><a href="#isinputparameter-boolean">isInputParameter : boolean</a></li>
<li><a href="#scope-parameterscope">scope : ParameterScope</a></li>
<li><a href="#sourcetype-string">sourceType : String</a></li>
<li><a href="#uncertainty-uncertainty-1">uncertainty : Uncertainty</a></li>
<li><a href="#value-double-1">value : double</a></li>
<li><a href="#clone-parameter">clone() : Parameter</a></li>
<li><a href="#isvalidname-boolean">isValidName() : boolean</a></li>
<li><a href="#tostring-string-4">toString() : String</a></li>
</ul></li>
<li><a href="#parameterredef-abstractentity">ParameterRedef &gt; AbstractEntity</a><ul>
<li><a href="#contextid-long">contextId : Long</a></li>
<li><a href="#contexttype-modeltype">contextType : ModelType</a></li>
<li><a href="#name-string">name : String</a></li>
<li><a href="#uncertainty-uncertainty-2">uncertainty : Uncertainty</a></li>
<li><a href="#value-double-2">value : double</a></li>
<li><a href="#clone-parameterredef">clone() : ParameterRedef</a></li>
</ul></li>
<li><a href="#parameterscope">ParameterScope</a><ul>
<li><a href="#process-1">PROCESS</a></li>
<li><a href="#impact_method-1">IMPACT_METHOD</a></li>
<li><a href="#global">GLOBAL</a></li>
</ul></li>
<li><a href="#processdocumentation-abstractentity-cloneable">ProcessDocumentation &gt; AbstractEntity, Cloneable</a><ul>
<li><a href="#completeness-string">completeness : String</a></li>
<li><a href="#copyright-boolean">copyright : boolean</a></li>
<li><a href="#creationdate-date">creationDate : Date</a></li>
<li><a href="#datacollectionperiod-string">dataCollectionPeriod : String</a></li>
<li><a href="#datadocumentor-actor">dataDocumentor : Actor</a></li>
<li><a href="#datagenerator-actor">dataGenerator : Actor</a></li>
<li><a href="#dataselection-string">dataSelection : String</a></li>
<li><a href="#datasetowner-actor">dataSetOwner : Actor</a></li>
<li><a href="#datatreatment-string">dataTreatment : String</a></li>
<li><a href="#geography-string">geography : String</a></li>
<li><a href="#intendedapplication-string">intendedApplication : String</a></li>
<li><a href="#inventorymethod-string">inventoryMethod : String</a></li>
<li><a href="#modelingconstants-string">modelingConstants : String</a></li>
<li><a href="#precedingdataset-string">precedingDataSet : String</a></li>
<li><a href="#project-string">project : String</a></li>
<li><a href="#publication-source">publication : Source</a></li>
<li><a href="#restrictions-string">restrictions : String</a></li>
<li><a href="#reviewdetails-string">reviewDetails : String</a></li>
<li><a href="#reviewer-actor">reviewer : Actor</a></li>
<li><a href="#sampling-string">sampling : String</a></li>
<li><a href="#sources-list">sources : List<Source></a></li>
<li><a href="#technology-string">technology : String</a></li>
<li><a href="#time-string">time : String</a></li>
<li><a href="#validfrom-date">validFrom : Date</a></li>
<li><a href="#validuntil-date">validUntil : Date</a></li>
<li><a href="#clone-processdocumentation">clone() : ProcessDocumentation</a></li>
</ul></li>
<li><a href="#processgroup-comparable">ProcessGroup &gt; Comparable</a><ul>
<li><a href="#name-string-1">name : String</a></li>
<li><a href="#processids-list">processIds : List<String></a></li>
<li><a href="#compareto-int-1">compareTo() : int</a></li>
<li><a href="#equals-boolean-4">equals() : boolean</a></li>
<li><a href="#hashcode-int-3">hashCode() : int</a></li>
</ul></li>
<li><a href="#processgroupset-abstractentity">ProcessGroupSet &gt; AbstractEntity</a><ul>
<li><a href="#name-string-2">name : String</a></li>
<li><a href="#getgroups-listprocessgroup">getGroups() : List&lt;ProcessGroup&gt;</a></li>
<li><a href="#setgroups-void">setGroups() : void</a></li>
</ul></li>
<li><a href="#processlink-cloneable">ProcessLink &gt; Cloneable</a><ul>
<li><a href="#exchangeid-long">exchangeId : long</a></li>
<li><a href="#flowid-long-1">flowId : long</a></li>
<li><a href="#issystemlink-boolean">isSystemLink : boolean</a></li>
<li><a href="#processid-long">processId : long</a></li>
<li><a href="#providerid-long">providerId : long</a></li>
<li><a href="#clone-processlink">clone() : ProcessLink</a></li>
<li><a href="#equals-boolean-5">equals() : boolean</a></li>
<li><a href="#hashcode-int-4">hashCode() : int</a></li>
</ul></li>
<li><a href="#rootentity-abstractentity-cloneable">RootEntity &gt; AbstractEntity, Cloneable</a><ul>
<li><a href="#description-string-1">description : String</a></li>
<li><a href="#lastchange-long">lastChange : long</a></li>
<li><a href="#name-string-3">name : String</a></li>
<li><a href="#refid-string">refId : String</a></li>
<li><a href="#version-long">version : long</a></li>
<li><a href="#clone-object">clone() : Object</a></li>
<li><a href="#tostring-string-5">toString() : String</a></li>
</ul></li>
<li><a href="#uncertainty">Uncertainty</a><ul>
<li><a href="#distributiontype-uncertaintytype">distributionType : UncertaintyType</a></li>
<li><a href="#formula1-string">formula1 : String</a></li>
<li><a href="#formula2-string">formula2 : String</a></li>
<li><a href="#formula3-string">formula3 : String</a></li>
<li><a href="#parameter1-double">parameter1 : Double</a></li>
<li><a href="#parameter2-double">parameter2 : Double</a></li>
<li><a href="#parameter3-double">parameter3 : Double</a></li>
<li><a href="#clone-uncertainty">clone() : Uncertainty</a></li>
<li><a href="#equals-boolean-6">equals() : boolean</a></li>
<li><a href="#fromstring-uncertainty">fromString() : Uncertainty</a></li>
<li><a href="#generator-numbergenerator">generator() : NumberGenerator</a></li>
<li><a href="#hashcode-int-5">hashCode() : int</a></li>
<li><a href="#lognormal-uncertainty">logNormal() : Uncertainty</a></li>
<li><a href="#none-uncertainty">none() : Uncertainty</a></li>
<li><a href="#normal-uncertainty">normal() : Uncertainty</a></li>
<li><a href="#scale-void">scale() : void</a></li>
<li><a href="#string-string">string() : String</a></li>
<li><a href="#tostring-string-6">toString() : String</a></li>
<li><a href="#triangle-uncertainty">triangle() : Uncertainty</a></li>
<li><a href="#uniform-uncertainty">uniform() : Uncertainty</a></li>
</ul></li>
<li><a href="#unitgroup-categorizedentity">UnitGroup &gt; CategorizedEntity</a><ul>
<li><a href="#defaultflowproperty-flowproperty">defaultFlowProperty : FlowProperty</a></li>
<li><a href="#referenceunit-unit">referenceUnit : Unit</a></li>
<li><a href="#units-list">units : List<Unit></a></li>
<li><a href="#clone-unitgroup">clone() : UnitGroup</a></li>
<li><a href="#getunit-unit-1">getUnit() : Unit</a></li>
</ul></li>
<li><a href="#version">Version</a><ul>
<li><a href="#version-1">Version()</a></li>
<li><a href="#version-2">Version()</a></li>
<li><a href="#version-3">Version()</a></li>
<li><a href="#asstring-string">asString() : String</a></li>
<li><a href="#equals-boolean-7">equals() : boolean</a></li>
<li><a href="#fromstring-version">fromString() : Version</a></li>
<li><a href="#getmajor-int">getMajor() : int</a></li>
<li><a href="#getminor-int">getMinor() : int</a></li>
<li><a href="#getupdate-int">getUpdate() : int</a></li>
<li><a href="#getvalue-long">getValue() : long</a></li>
<li><a href="#hashcode-int-6">hashCode() : int</a></li>
<li><a href="#incmajor-void">incMajor() : void</a></li>
<li><a href="#incmajor-void-1">incMajor() : void</a></li>
<li><a href="#incminor-void">incMinor() : void</a></li>
<li><a href="#incminor-void-1">incMinor() : void</a></li>
<li><a href="#incupdate-void">incUpdate() : void</a></li>
<li><a href="#incupdate-void-1">incUpdate() : void</a></li>
<li><a href="#setmajor-void">setMajor() : void</a></li>
<li><a href="#setminor-void">setMinor() : void</a></li>
<li><a href="#setupdate-void">setUpdate() : void</a></li>
<li><a href="#tostring-string-7">toString() : String</a></li>
<li><a href="#valueof-long">valueOf() : long</a></li>
</ul></li>
</ul></li>
<li><a href="#package-org.openlca.core.model.descriptors">Package: org.openlca.core.model.descriptors</a><ul>
<li><a href="#basedescriptor">BaseDescriptor</a><ul>
<li><a href="#description-string-2">description : String</a></li>
<li><a href="#id-long-2">id : long</a></li>
<li><a href="#lastchange-long-1">lastChange : long</a></li>
<li><a href="#name-string-4">name : String</a></li>
<li><a href="#refid-string-1">refId : String</a></li>
<li><a href="#type-modeltype">type : ModelType</a></li>
<li><a href="#version-long-1">version : long</a></li>
<li><a href="#equals-boolean-8">equals() : boolean</a></li>
<li><a href="#hashcode-int-7">hashCode() : int</a></li>
<li><a href="#tostring-string-8">toString() : String</a></li>
</ul></li>
<li><a href="#impactcategorydescriptor-basedescriptor">ImpactCategoryDescriptor &gt; BaseDescriptor</a><ul>
<li><a href="#impactcategorydescriptor">ImpactCategoryDescriptor()</a></li>
<li><a href="#referenceunit-string">referenceUnit : String</a></li>
</ul></li>
<li><a href="#impactmethoddescriptor-categorizeddescriptor">ImpactMethodDescriptor &gt; CategorizedDescriptor</a><ul>
<li><a href="#impactmethoddescriptor">ImpactMethodDescriptor()</a></li>
</ul></li>
</ul></li>
<li><a href="#package-org.openlca.core.results">Package: org.openlca.core.results</a><ul>
<li><a href="#baseresult-iresult">BaseResult &gt; IResult</a><ul>
<li><a href="#flowindex-flowindex-1">flowIndex : FlowIndex</a></li>
<li><a href="#impactindex-dindex-2">impactIndex : DIndex<ImpactCategoryDescriptor></a></li>
<li><a href="#techindex-techindex-2">techIndex : TechIndex</a></li>
<li><a href="#getflows-setflowdescriptor">getFlows() : Set&lt;FlowDescriptor&gt;</a></li>
<li><a href="#getimpacts-setimpactcategorydescriptor">getImpacts() : Set&lt;ImpactCategoryDescriptor&gt;</a></li>
<li><a href="#getprocesses-setcategorizeddescriptor">getProcesses() : Set&lt;CategorizedDescriptor&gt;</a></li>
<li><a href="#getproviders-setprocessproduct">getProviders() : Set&lt;ProcessProduct&gt;</a></li>
<li><a href="#hasflowresults-boolean">hasFlowResults() : boolean</a></li>
<li><a href="#hasimpactresults-boolean">hasImpactResults() : boolean</a></li>
<li><a href="#isinput-boolean-3">isInput() : boolean</a></li>
</ul></li>
<li><a href="#contributionresult-simpleresult">ContributionResult &gt; SimpleResult</a><ul>
<li><a href="#directcostresults-double">directCostResults : double[]</a></li>
<li><a href="#directflowimpacts-imatrix">directFlowImpacts : IMatrix</a></li>
<li><a href="#directflowresults-imatrix">directFlowResults : IMatrix</a></li>
<li><a href="#directimpactresults-imatrix">directImpactResults : IMatrix</a></li>
<li><a href="#impactfactors-imatrix">impactFactors : IMatrix</a></li>
<li><a href="#getdirectcostresult-double">getDirectCostResult() : double</a></li>
<li><a href="#getdirectcostresult-double-1">getDirectCostResult() : double</a></li>
<li><a href="#getdirectflowimpact-double">getDirectFlowImpact() : double</a></li>
<li><a href="#getdirectflowresult-double">getDirectFlowResult() : double</a></li>
<li><a href="#getdirectflowresult-double-1">getDirectFlowResult() : double</a></li>
<li><a href="#getdirectimpactresult-double">getDirectImpactResult() : double</a></li>
<li><a href="#getdirectimpactresult-double-1">getDirectImpactResult() : double</a></li>
<li><a href="#getflowcontributions-listflowresult">getFlowContributions() : List&lt;FlowResult&gt;</a></li>
<li><a href="#getflowcontributions-listflowresult-1">getFlowContributions() : List&lt;FlowResult&gt;</a></li>
<li><a href="#getimpactcontributions-listimpactresult">getImpactContributions() : List&lt;ImpactResult&gt;</a></li>
<li><a href="#getprocesscontributions-contributionsetcategorizeddescriptor">getProcessContributions() : ContributionSet&lt;CategorizedDescriptor&gt;</a></li>
<li><a href="#getprocesscontributions-contributionsetcategorizeddescriptor-1">getProcessContributions() : ContributionSet&lt;CategorizedDescriptor&gt;</a></li>
<li><a href="#getprocesscostcontributions-contributionsetcategorizeddescriptor">getProcessCostContributions() : ContributionSet&lt;CategorizedDescriptor&gt;</a></li>
<li><a href="#hascostresults-boolean">hasCostResults() : boolean</a></li>
</ul></li>
<li><a href="#contributionset">ContributionSet</a><ul>
<li><a href="#contributionset-1">ContributionSet()</a></li>
<li><a href="#contributions-listcontributionitem">contributions : List&lt;ContributionItem<T>&gt;</a></li>
<li><a href="#empty-contributionsett">empty() : ContributionSet&lt;T&gt;</a></li>
<li><a href="#getcontribution-contributionitemt">getContribution() : ContributionItem&lt;T&gt;</a></li>
</ul></li>
<li><a href="#fullresult-contributionresult">FullResult &gt; ContributionResult</a><ul>
<li><a href="#loopfactor-double">loopFactor : double</a></li>
<li><a href="#techmatrix-imatrix-1">techMatrix : IMatrix</a></li>
<li><a href="#upstreamcostresults-imatrix">upstreamCostResults : IMatrix</a></li>
<li><a href="#upstreamflowresults-imatrix">upstreamFlowResults : IMatrix</a></li>
<li><a href="#upstreamimpactresults-imatrix">upstreamImpactResults : IMatrix</a></li>
<li><a href="#getaddedvaluetree-upstreamtree">getAddedValueTree() : UpstreamTree</a></li>
<li><a href="#getcosttree-upstreamtree">getCostTree() : UpstreamTree</a></li>
<li><a href="#getlinkshare-double">getLinkShare() : double</a></li>
<li><a href="#gettree-upstreamtree">getTree() : UpstreamTree</a></li>
<li><a href="#gettree-upstreamtree-1">getTree() : UpstreamTree</a></li>
<li><a href="#getupstreamcostresult-double">getUpstreamCostResult() : double</a></li>
<li><a href="#getupstreamcostresult-double-1">getUpstreamCostResult() : double</a></li>
<li><a href="#getupstreamflowresult-double">getUpstreamFlowResult() : double</a></li>
<li><a href="#getupstreamflowresult-double-1">getUpstreamFlowResult() : double</a></li>
<li><a href="#getupstreamflowresults-listflowresult">getUpstreamFlowResults() : List&lt;FlowResult&gt;</a></li>
<li><a href="#getupstreamimpactresult-double">getUpstreamImpactResult() : double</a></li>
<li><a href="#getupstreamimpactresult-double-1">getUpstreamImpactResult() : double</a></li>
<li><a href="#getupstreamimpactresults-listimpactresult">getUpstreamImpactResults() : List&lt;ImpactResult&gt;</a></li>
</ul></li>
<li><a href="#groupingcontribution">GroupingContribution</a><ul>
<li><a href="#groupingcontribution-1">GroupingContribution()</a></li>
<li><a href="#calculate-contributionsetprocessgrouping">calculate() : ContributionSet&lt;ProcessGrouping&gt;</a></li>
<li><a href="#calculate-contributionsetprocessgrouping-1">calculate() : ContributionSet&lt;ProcessGrouping&gt;</a></li>
</ul></li>
<li><a href="#iresult">IResult</a><ul>
<li><a href="#getflows-setflowdescriptor-1">getFlows() : Set&lt;FlowDescriptor&gt;</a></li>
<li><a href="#getimpacts-setimpactcategorydescriptor-1">getImpacts() : Set&lt;ImpactCategoryDescriptor&gt;</a></li>
<li><a href="#getprocesses-setcategorizeddescriptor-1">getProcesses() : Set&lt;CategorizedDescriptor&gt;</a></li>
<li><a href="#hascostresults-boolean-1">hasCostResults() : boolean</a></li>
<li><a href="#hasflowresults-boolean-1">hasFlowResults() : boolean</a></li>
<li><a href="#hasimpactresults-boolean-1">hasImpactResults() : boolean</a></li>
<li><a href="#isinput-boolean-4">isInput() : boolean</a></li>
</ul></li>
<li><a href="#locationcontribution">LocationContribution</a><ul>
<li><a href="#locationcontribution-1">LocationContribution()</a></li>
<li><a href="#addedvalues-contributionsetlocation">addedValues() : ContributionSet&lt;Location&gt;</a></li>
<li><a href="#calculate-contributionsetlocation">calculate() : ContributionSet&lt;Location&gt;</a></li>
<li><a href="#calculate-contributionsetlocation-1">calculate() : ContributionSet&lt;Location&gt;</a></li>
<li><a href="#netcosts-contributionsetlocation">netCosts() : ContributionSet&lt;Location&gt;</a></li>
</ul></li>
<li><a href="#processgrouping">ProcessGrouping</a><ul>
<li><a href="#name-string-5">name : String</a></li>
<li><a href="#processes-list">processes : List<CategorizedDescriptor></a></li>
<li><a href="#rest-boolean">rest : boolean</a></li>
<li><a href="#applyon-listprocessgrouping">applyOn() : List&lt;ProcessGrouping&gt;</a></li>
<li><a href="#equals-boolean-9">equals() : boolean</a></li>
<li><a href="#hashcode-int-8">hashCode() : int</a></li>
</ul></li>
<li><a href="#projectresult-iresult">ProjectResult &gt; IResult</a><ul>
<li><a href="#addresult-void">addResult() : void</a></li>
<li><a href="#getcontributions-contributionsetprojectvariant">getContributions() : ContributionSet&lt;ProjectVariant&gt;</a></li>
<li><a href="#getcontributions-contributionsetprojectvariant-1">getContributions() : ContributionSet&lt;ProjectVariant&gt;</a></li>
<li><a href="#getflows-setflowdescriptor-2">getFlows() : Set&lt;FlowDescriptor&gt;</a></li>
<li><a href="#getimpacts-setimpactcategorydescriptor-2">getImpacts() : Set&lt;ImpactCategoryDescriptor&gt;</a></li>
<li><a href="#getprocesses-setcategorizeddescriptor-2">getProcesses() : Set&lt;CategorizedDescriptor&gt;</a></li>
<li><a href="#getresult-contributionresult">getResult() : ContributionResult</a></li>
<li><a href="#gettotalflowresult-double">getTotalFlowResult() : double</a></li>
<li><a href="#gettotalflowresults-listflowresult">getTotalFlowResults() : List&lt;FlowResult&gt;</a></li>
<li><a href="#gettotalimpactresult-double">getTotalImpactResult() : double</a></li>
<li><a href="#getvariants-setprojectvariant">getVariants() : Set&lt;ProjectVariant&gt;</a></li>
<li><a href="#hascostresults-boolean-2">hasCostResults() : boolean</a></li>
<li><a href="#hasflowresults-boolean-2">hasFlowResults() : boolean</a></li>
<li><a href="#hasimpactresults-boolean-2">hasImpactResults() : boolean</a></li>
<li><a href="#isinput-boolean-5">isInput() : boolean</a></li>
</ul></li>
<li><a href="#simpleresult-baseresult">SimpleResult &gt; BaseResult</a><ul>
<li><a href="#scalingvector-double">scalingVector : double[]</a></li>
<li><a href="#totalcosts-double">totalCosts : double</a></li>
<li><a href="#totalflowresults-double">totalFlowResults : double[]</a></li>
<li><a href="#totalimpactresults-double">totalImpactResults : double[]</a></li>
<li><a href="#totalrequirements-double">totalRequirements : double[]</a></li>
<li><a href="#getscalingfactor-double">getScalingFactor() : double</a></li>
<li><a href="#getscalingfactor-double-1">getScalingFactor() : double</a></li>
<li><a href="#gettotalflowresult-double-1">getTotalFlowResult() : double</a></li>
<li><a href="#gettotalflowresults-listflowresult-1">getTotalFlowResults() : List&lt;FlowResult&gt;</a></li>
<li><a href="#gettotalimpactresult-double-1">getTotalImpactResult() : double</a></li>
<li><a href="#gettotalimpactresults-listimpactresult">getTotalImpactResults() : List&lt;ImpactResult&gt;</a></li>
<li><a href="#hascostresults-boolean-3">hasCostResults() : boolean</a></li>
</ul></li>
<li><a href="#simulationresult-baseresult">SimulationResult &gt; BaseResult</a><ul>
<li><a href="#simulationresult">SimulationResult()</a></li>
<li><a href="#append-void">append() : void</a></li>
<li><a href="#append-void-1">append() : void</a></li>
<li><a href="#get-double-8">get() : double</a></li>
<li><a href="#get-double-9">get() : double</a></li>
<li><a href="#getall-double">getAll() : double[]</a></li>
<li><a href="#getall-double-1">getAll() : double[]</a></li>
<li><a href="#getalldirect-double">getAllDirect() : double[]</a></li>
<li><a href="#getalldirect-double-1">getAllDirect() : double[]</a></li>
<li><a href="#getallupstream-double">getAllUpstream() : double[]</a></li>
<li><a href="#getallupstream-double-1">getAllUpstream() : double[]</a></li>
<li><a href="#getdirect-double">getDirect() : double</a></li>
<li><a href="#getdirect-double-1">getDirect() : double</a></li>
<li><a href="#getnumberofruns-int">getNumberOfRuns() : int</a></li>
<li><a href="#getpinnedproducts-setprocessproduct">getPinnedProducts() : Set&lt;ProcessProduct&gt;</a></li>
<li><a href="#getupstream-double">getUpstream() : double</a></li>
<li><a href="#getupstream-double-1">getUpstream() : double</a></li>
<li><a href="#hascostresults-boolean-4">hasCostResults() : boolean</a></li>
</ul></li>
<li><a href="#statistics">Statistics</a><ul>
<li><a href="#count-int">count : int</a></li>
<li><a href="#max-double">max : double</a></li>
<li><a href="#mean-double">mean : double</a></li>
<li><a href="#median-double">median : double</a></li>
<li><a href="#min-double">min : double</a></li>
<li><a href="#range-double">range : double</a></li>
<li><a href="#standarddeviation-double">standardDeviation : double</a></li>
<li><a href="#empty-statistics">empty() : Statistics</a></li>
<li><a href="#getpercentilevalue-double">getPercentileValue() : double</a></li>
<li><a href="#hist-histogram">hist() : Histogram</a></li>
<li><a href="#of-statistics">of() : Statistics</a></li>
</ul></li>
<li><a href="#upstreamnode">UpstreamNode</a><ul>
<li><a href="#provider-processproduct">provider : ProcessProduct</a></li>
<li><a href="#result-double">result : double</a></li>
</ul></li>
<li><a href="#upstreamtree">UpstreamTree</a><ul>
<li><a href="#upstreamtree-1">UpstreamTree()</a></li>
<li><a href="#upstreamtree-2">UpstreamTree()</a></li>
<li><a href="#ref-basedescriptor">ref : BaseDescriptor</a></li>
<li><a href="#root-upstreamnode">root : UpstreamNode</a></li>
<li><a href="#childs-listupstreamnode">childs() : List&lt;UpstreamNode&gt;</a></li>
</ul></li>
</ul></li>
<li><a href="#package-org.openlca.eigen">Package: org.openlca.eigen</a><ul>
<li><a href="#nativelibrary">NativeLibrary</a><ul>
<li><a href="#isloaded-boolean">isLoaded() : boolean</a></li>
<li><a href="#loadfromdir-void">loadFromDir() : void</a></li>
</ul></li>
</ul></li>
<li><a href="#package-org.openlca.julia">Package: org.openlca.julia</a><ul>
<li><a href="#julia">Julia</a><ul>
<li><a href="#invert-int">invert() : int</a></li>
<li><a href="#isloaded-boolean-1">isLoaded() : boolean</a></li>
<li><a href="#iswithumfpack-boolean">isWithUmfpack() : boolean</a></li>
<li><a href="#load-boolean">load() : boolean</a></li>
<li><a href="#loadfromdir-boolean">loadFromDir() : boolean</a></li>
<li><a href="#mmult-void">mmult() : void</a></li>
<li><a href="#mvmult-void">mvmult() : void</a></li>
<li><a href="#solve-int">solve() : int</a></li>
<li><a href="#umfdispose-void">umfDispose() : void</a></li>
<li><a href="#umffactorize-long">umfFactorize() : long</a></li>
<li><a href="#umfsolve-void">umfSolve() : void</a></li>
<li><a href="#umfsolvefactorized-long">umfSolveFactorized() : long</a></li>
</ul></li>
</ul></li>
<li><a href="#package-org.openlca.util">Package: org.openlca.util</a><ul>
<li><a href="#categories">Categories</a><ul>
<li><a href="#createrefid-string">createRefId() : String</a></li>
<li><a href="#path-liststring">path() : List&lt;String&gt;</a></li>
</ul></li>
<li><a href="#dirs">Dirs</a><ul>
<li><a href="#clean-void">clean() : void</a></li>
<li><a href="#copy-void">copy() : void</a></li>
<li><a href="#delete-void">delete() : void</a></li>
<li><a href="#delete-void-1">delete() : void</a></li>
<li><a href="#make-void">make() : void</a></li>
<li><a href="#make-void-1">make() : void</a></li>
<li><a href="#move-void">move() : void</a></li>
<li><a href="#size-long">size() : long</a></li>
</ul></li>
<li><a href="#keygen">KeyGen</a><ul>
<li><a href="#null_uuid-string">NULL_UUID : String</a></li>
<li><a href="#get-string">get() : String</a></li>
<li><a href="#topath-string">toPath() : String</a></li>
</ul></li>
<li><a href="#os">OS</a><ul>
<li><a href="#linux">LINUX</a></li>
<li><a href="#mac">MAC</a></li>
<li><a href="#windows">WINDOWS</a></li>
<li><a href="#other">OTHER</a></li>
<li><a href="#get-os">get() : OS</a></li>
<li><a href="#gettempdir-file">getTempDir() : File</a></li>
<li><a href="#tostring-string-9">toString() : String</a></li>
</ul></li>
<li><a href="#refidmap">RefIdMap</a><ul>
<li><a href="#get-to">get() : To</a></li>
<li><a href="#internaltoref-refidmaplong-string">internalToRef() : RefIdMap&lt;Long, String&gt;</a></li>
<li><a href="#reftointernal-refidmapstring-long">refToInternal() : RefIdMap&lt;String, Long&gt;</a></li>
</ul></li>
<li><a href="#strings">Strings</a><ul>
<li><a href="#append-string">append() : String[]</a></li>
<li><a href="#compare-int">compare() : int</a></li>
<li><a href="#cut-string">cut() : String</a></li>
<li><a href="#join-string">join() : String</a></li>
<li><a href="#join-string-1">join() : String</a></li>
<li><a href="#notempty-boolean">notEmpty() : boolean</a></li>
<li><a href="#nullorempty-boolean">nullOrEmpty() : boolean</a></li>
<li><a href="#nullorequal-boolean">nullOrEqual() : boolean</a></li>
<li><a href="#prepend-string">prepend() : String[]</a></li>
<li><a href="#readlines-string">readLines() : String[]</a></li>
</ul></li>
<li><a href="#toposort">TopoSort</a><ul>
<li><a href="#of-listlong">of() : List&lt;Long&gt;</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h1 id="how-to-read-this-document">How to read this document</h1>
<p>This document contains the documentation of the openLCA core API, automatically extracted from the Java documentation of the <a href="https://github.com/GreenDelta/olca-modules">olca-modules repository</a> (using the <a href="https://github.com/msrocka/jmd">jmd tool</a>). The headings of this document follow the structure of the API:</p>
<ol type="1">
<li>Packages (e.g. <code>org.openlca.core.results</code>)</li>
<li>Types (mainly classes), e.g. <code>ContributionResult</code></li>
<li>Fields (e.g. <code>techIndex</code>) and methods (e.g. <code>getFlows()</code>)</li>
</ol>
<p>A heading <code>TypeB &gt; TypeA</code> means that the following section is about <code>TypeB</code> which extends <code>TypeA</code> and, thus, has all the methods and fields that <code>TypeA</code> has. The heading <code>fieldC : TypeD</code> means that <code>fieldC</code> is an accessible field (a property) of type <code>TypeD</code>. Finally, a heading <code>methodG(): TypeE</code> means that <code>methodG</code> is a callable method that returns an instance of <code>TypeE</code>. The parameters of that method are directly listed after the heading in the same order as they need to be applied when calling the method. Methods that have the same name as their type (like <code>TypeG()</code>) are constructor methods which create a new instance of that type.</p>
<p>The openLCA core API is a plain Java API that should run on any Java Virtual Machine (JVM) &gt;= v8. Thus, you could use it from any JVM language like Java, Scala, Kotlin, Clojure, Jython, etc. It is also fully exposed to the openLCA development tools within openLCA (<code>Window &gt; Developer tools &gt; Python</code> within openLCA). The Python scripting environment in openLCA uses <a href="http://www.jython.org/">Jython</a> (a Python implementation that runs on the JVM). The following example shows how the usage of the elements <code>package</code>, <code>type</code>, <code>field</code>, and <code>method</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="co"># import the type &#39;FlowDao&#39; from the package</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="co"># &#39;org.openlca.core.database&#39;</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="im">from</span> org.openlca.core.database <span class="im">import</span> FlowDao</a>
<a class="sourceLine" id="cb1-4" title="4"></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="co"># create a new instance of &quot;FlowDao&quot; by calling</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="co"># its constructor method and passing a database</span></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="co"># instance as parameter</span></a>
<a class="sourceLine" id="cb1-8" title="8">dao <span class="op">=</span> FlowDao(db)</a>
<a class="sourceLine" id="cb1-9" title="9"></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="co"># get all flows by calling the method &quot;getAll&quot;</span></a>
<a class="sourceLine" id="cb1-11" title="11"><span class="co"># on the instance of the FlowDao type</span></a>
<a class="sourceLine" id="cb1-12" title="12">flows <span class="op">=</span> dao.getAll()</a>
<a class="sourceLine" id="cb1-13" title="13"></a>
<a class="sourceLine" id="cb1-14" title="14"><span class="co"># writing the value of the field &quot;name&quot; of the</span></a>
<a class="sourceLine" id="cb1-15" title="15"><span class="co"># first flow to the logger output</span></a>
<a class="sourceLine" id="cb1-16" title="16">log.info(<span class="st">&quot;Name of the first flow: </span><span class="sc">{}</span><span class="st">&quot;</span>, flows[<span class="dv">0</span>].name)</a></code></pre></div>
<h1 id="package-org.openlca.core.database">Package: org.openlca.core.database</h1>
<h2 id="blockfetch">BlockFetch</h2>
<p>Provides the functionality for loading of data for a given set of IDs with a minimal amount of queries but with block sizes of ID sets that are not greater than the allowed maximum list size for queries (see {<span class="citation" data-cites="link">@link</span> BaseDao#MAX_LIST_SIZE}).</p>
<h3 id="blockfetch-1">BlockFetch()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>func : QueryFunction<T></li>
</ul>
<p><em>undocumented</em></p>
<h3 id="dofetch-listt">doFetch() : List&lt;T&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>ids : List<Long></li>
<li>function : QueryFunction<T></li>
</ul>
<p>Creates a new BlockFetch and runs the given query function.</p>
<h3 id="dofetch-listt-1">doFetch() : List&lt;T&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>ids : List<Long></li>
</ul>
<p>Split the given IDs into chunks with a size not greater than {<span class="citation" data-cites="link">@link</span> Dao#MAX_LIST_SIZE}, run the queries and return the results.</p>
<h2 id="dataproviderexception-exception">DataProviderException &gt; Exception</h2>
<p>Exception which can be thrown by data operations.</p>
<h3 id="dataproviderexception">DataProviderException()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>message : String</li>
</ul>
<p>Creates a new instance</p>
<p><span class="citation" data-cites="param">@param</span> message The message of the exception</p>
<h3 id="dataproviderexception-1">DataProviderException()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>message : String</li>
<li>throwable : Throwable</li>
</ul>
<p>Creates a new instance</p>
<p><span class="citation" data-cites="param">@param</span> message The message of the exception <span class="citation" data-cites="param">@param</span> throwable The cause of the exception</p>
<h3 id="dataproviderexception-2">DataProviderException()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>throwable : Throwable</li>
</ul>
<p>Creates a new instance</p>
<p><span class="citation" data-cites="param">@param</span> throwable The cause of the exception</p>
<h2 id="databaseexception-runtimeexception">DatabaseException &gt; RuntimeException</h2>
<p>Unchecked exception for errors while invoking database operations. These exceptions are already logged and are only thrown so interested caller can handle exceptions</p>
<h3 id="databaseexception">DatabaseException()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>message : String</li>
<li>e : Throwable</li>
</ul>
<p><em>undocumented</em></p>
<h2 id="entitycache">EntityCache</h2>
<p>A loading cache for entities and descriptors. This cache is intended to be used for caching entities that are used very often (like unit groups or flow properties) and descriptors.</p>
<h3 id="create-entitycache">create() : EntityCache</h3>
<p><em>Parameters:</em></p>
<ul>
<li>database : IDatabase</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="get-t">get() : T</h3>
<p><em>Parameters:</em></p>
<ul>
<li>clazz : Class<T></li>
<li>id : long</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="getall-maplong-t">getAll() : Map&lt;Long, T&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>clazz : Class<T></li>
<li>ids : Collection<Long></li>
</ul>
<p><em>undocumented</em></p>
<h3 id="invalidate-void">invalidate() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>clazz : Class&lt;?&gt;</li>
<li>id : long</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="invalidateall-void">invalidateAll() : void</h3>
<p><em>undocumented</em></p>
<h3 id="invalidateall-void-1">invalidateAll() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>clazz : Class&lt;?&gt;</li>
<li>ids : Collection<Long></li>
</ul>
<p><em>undocumented</em></p>
<h3 id="refresh-void">refresh() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>clazz : Class&lt;?&gt;</li>
<li>id : long</li>
</ul>
<p><em>undocumented</em></p>
<h2 id="filestore">FileStore</h2>
<p>Provides structured access to files that are stored outside of a database. Such files can be shapefiles of LCIA methods, PDF documents of sources etc.</p>
<h3 id="filestore-1">FileStore()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>rootFolder : File</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="filestore-2">FileStore()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>db : IDatabase</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="copyfolder-void">copyFolder() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>from : RootEntity</li>
<li>to : RootEntity</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="copyfolder-void-1">copyFolder() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>from : BaseDescriptor</li>
<li>to : BaseDescriptor</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="copyfolder-void-2">copyFolder() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>type : ModelType</li>
<li>fromId : String</li>
<li>toId : String</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="deletefolder-void">deleteFolder() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>d : BaseDescriptor</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="deletefolder-void-1">deleteFolder() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>e : RootEntity</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="deletefolder-void-2">deleteFolder() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>type : ModelType</li>
<li>id : String</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="getfolder-file">getFolder() : File</h3>
<p><em>Parameters:</em></p>
<ul>
<li>d : BaseDescriptor</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="getfolder-file-1">getFolder() : File</h3>
<p><em>Parameters:</em></p>
<ul>
<li>e : RootEntity</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="getfolder-file-2">getFolder() : File</h3>
<p><em>Parameters:</em></p>
<ul>
<li>type : ModelType</li>
<li>id : String</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="getpath-string">getPath() : String</h3>
<p><em>Parameters:</em></p>
<ul>
<li>type : ModelType</li>
</ul>
<p>Returns the path/folder name for the given model type (e.g. ‘processes’, ‘flow_properties’ etc).</p>
<h3 id="getpath-string-1">getPath() : String</h3>
<p><em>Parameters:</em></p>
<ul>
<li>type : ModelType</li>
<li>refId : String</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="getroot-file">getRoot() : File</h3>
<p><em>undocumented</em></p>
<h2 id="idatabase-closeable-inotifiable">IDatabase &gt; Closeable, INotifiable</h2>
<p>The common interface for openLCA databases.</p>
<h3 id="createconnection-connection">createConnection() : Connection</h3>
<p>Creates a native SQL connection to the underlying database. The connection should be closed from the respective client.</p>
<h3 id="getentityfactory-entitymanagerfactory">getEntityFactory() : EntityManagerFactory</h3>
<p>Returns the entity manager factory from the database.</p>
<h3 id="getfilestoragelocation-file">getFileStorageLocation() : File</h3>
<p>Get a location where external files that belongs this database are stored (e.g. PDF or Word documents, shapefiles etc). If there is no such location for such files for this database, an implementation can just return null.</p>
<h3 id="getname-string">getName() : String</h3>
<p>Returns the database name.</p>
<h3 id="getversion-int">getVersion() : int</h3>
<p><em>undocumented</em></p>
<h2 id="impactmethoddao-categorizedentitydao">ImpactMethodDao &gt; CategorizedEntityDao</h2>
<p>The DAO class for impact assessment methods.</p>
<h3 id="impactmethoddao">ImpactMethodDao()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>database : IDatabase</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="getcategorydescriptors-listimpactcategorydescriptor">getCategoryDescriptors() : List&lt;ImpactCategoryDescriptor&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>methodId : long</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="getcategorydescriptors-listimpactcategorydescriptor-1">getCategoryDescriptors() : List&lt;ImpactCategoryDescriptor&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>methodId : String</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="getnwsetdescriptors-listnwsetdescriptor">getNwSetDescriptors() : List&lt;NwSetDescriptor&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>methodId : long</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="getnwsetdescriptors-listnwsetdescriptor-1">getNwSetDescriptors() : List&lt;NwSetDescriptor&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>methodId : String</li>
</ul>
<p><em>undocumented</em></p>
<h2 id="query">Query</h2>
<p>A helper class for common queries.</p>
<h3 id="getall-listt">getAll() : List&lt;T&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>type : Class<T></li>
<li>jpql : String</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="getall-listt-1">getAll() : List&lt;T&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>type : Class<T></li>
<li>jpql : String</li>
<li>params : Map&lt;String, ? extends Object&gt;</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="getallforname-listt">getAllForName() : List&lt;T&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>type : Class<T></li>
<li>name : String</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="getfirst-t">getFirst() : T</h3>
<p><em>Parameters:</em></p>
<ul>
<li>type : Class<T></li>
<li>jpql : String</li>
<li>params : Map&lt;String, ? extends Object&gt;</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="getforname-t">getForName() : T</h3>
<p><em>Parameters:</em></p>
<ul>
<li>type : Class<T></li>
<li>name : String</li>
</ul>
<p>Searches an entity of the given type with the given name. The type must have a string field ‘name’. If no such type is contained in the database, null is returned.</p>
<h3 id="on-query">on() : Query</h3>
<p><em>Parameters:</em></p>
<ul>
<li>database : IDatabase</li>
</ul>
<p><em>undocumented</em></p>
<h1 id="package-org.openlca.core.database.derby">Package: org.openlca.core.database.derby</h1>
<h1 id="package-org.openlca.core.database.mysql">Package: org.openlca.core.database.mysql</h1>
<h2 id="databasedescriptor">DatabaseDescriptor</h2>
<p>The descriptor of a database.</p>
<h3 id="getname-string-1">getName() : String</h3>
<p><em>undocumented</em></p>
<h3 id="getversion-int-1">getVersion() : int</h3>
<p><em>undocumented</em></p>
<h3 id="isuptodate-boolean">isUpToDate() : boolean</h3>
<p><em>undocumented</em></p>
<h3 id="setname-void">setName() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>name : String</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="setuptodate-void">setUpToDate() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>upToDate : boolean</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="setversion-void">setVersion() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>version : int</li>
</ul>
<p><em>undocumented</em></p>
<h2 id="mysqldatabase-notifiable-idatabase">MySQLDatabase &gt; Notifiable, IDatabase</h2>
<p>IDatabase implementation for MySQL database. The URL schema is “jdbc:mysql://” [host] “:” [port] “/” [database]</p>
<h3 id="mysqldatabase">MySQLDatabase()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>url : String</li>
<li>user : String</li>
<li>password : String</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="mysqldatabase-1">MySQLDatabase()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>url : String</li>
<li>user : String</li>
<li>password : String</li>
<li>persistenceUnit : String</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="close-void">close() : void</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="createconnection-connection-1">createConnection() : Connection</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="getentityfactory-entitymanagerfactory-1">getEntityFactory() : EntityManagerFactory</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="getfilestoragelocation-file-1">getFileStorageLocation() : File</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="getname-string-2">getName() : String</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="getversion-int-2">getVersion() : int</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="setfilestoragelocation-void">setFileStorageLocation() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>fileStorageLocation : File</li>
</ul>
<p><em>undocumented</em></p>
<h1 id="package-org.openlca.core.database.references">Package: org.openlca.core.database.references</h1>
<h2 id="ireferencesearch">IReferenceSearch</h2>
<p>Search of used entities within an entity.</p>
<h3 id="factory-factory">FACTORY : Factory</h3>
<p><em>undocumented</em></p>
<h3 id="findreferences-listreference">findReferences() : List&lt;Reference&gt;</h3>
<p><em>undocumented</em></p>
<h3 id="findreferences-listreference-1">findReferences() : List&lt;Reference&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>id : long</li>
</ul>
<p>Returns a list of descriptors of entities that are used in the entity with the given id</p>
<h3 id="findreferences-listreference-2">findReferences() : List&lt;Reference&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>entity : T</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="findreferences-listreference-3">findReferences() : List&lt;Reference&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>entity : List<T></li>
</ul>
<p><em>undocumented</em></p>
<h3 id="findreferences-listreference-4">findReferences() : List&lt;Reference&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>entity : Set<Long></li>
</ul>
<p><em>undocumented</em></p>
<h1 id="package-org.openlca.core.database.usage">Package: org.openlca.core.database.usage</h1>
<h2 id="actorusesearch-baseusesearch">ActorUseSearch &gt; BaseUseSearch</h2>
<p>Searches for the use of actors in other entities. Actors can be used in processes and projects.</p>
<h3 id="actorusesearch">ActorUseSearch()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>database : IDatabase</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="finduses-listcategorizeddescriptor">findUses() : List&lt;CategorizedDescriptor&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>ids : Set<Long></li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h2 id="categoryusesearch-baseusesearch">CategoryUseSearch &gt; BaseUseSearch</h2>
<p>Searches for the use of currencies in other entities. Currencies can be used in processes.</p>
<h3 id="categoryusesearch">CategoryUseSearch()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>database : IDatabase</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="finduses-listcategorizeddescriptor-1">findUses() : List&lt;CategorizedDescriptor&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>ids : Set<Long></li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h2 id="currencyusesearch-baseusesearch">CurrencyUseSearch &gt; BaseUseSearch</h2>
<p>Searches for the use of currencies in other entities. Currencies can be used in processes and other currencies.</p>
<h3 id="currencyusesearch">CurrencyUseSearch()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>database : IDatabase</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="finduses-listcategorizeddescriptor-2">findUses() : List&lt;CategorizedDescriptor&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>ids : Set<Long></li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h2 id="dqsystemusesearch-baseusesearch">DQSystemUseSearch &gt; BaseUseSearch</h2>
<p>Searches for the use of data quality systems in other entities. DQSystems can be used in processes.</p>
<h3 id="dqsystemusesearch">DQSystemUseSearch()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>database : IDatabase</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="finduses-listcategorizeddescriptor-3">findUses() : List&lt;CategorizedDescriptor&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>ids : Set<Long></li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h2 id="exchangeusesearch">ExchangeUseSearch</h2>
<p>Searches for the use of process exchanges in other entities. Exchanges of a process can be used in product systems as quantitative reference or in process links.</p>
<h3 id="exchangeusesearch-1">ExchangeUseSearch()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>database : IDatabase</li>
<li>process : Process</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="finduses-listcategorizeddescriptor-4">findUses() : List&lt;CategorizedDescriptor&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>exchange : Exchange</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="finduses-listcategorizeddescriptor-5">findUses() : List&lt;CategorizedDescriptor&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>exchanges : List<Exchange></li>
</ul>
<p><em>undocumented</em></p>
<h2 id="flowpropertyfactorusesearch">FlowPropertyFactorUseSearch</h2>
<p>Searches for the usage of flow property factors of a given flow in other entities of the database.</p>
<h3 id="flowpropertyfactorusesearch-1">FlowPropertyFactorUseSearch()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>flow : Flow</li>
<li>database : IDatabase</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="finduses-listcategorizeddescriptor-6">findUses() : List&lt;CategorizedDescriptor&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>factor : FlowPropertyFactor</li>
</ul>
<p><em>undocumented</em></p>
<h2 id="flowpropertyusesearch-baseusesearch">FlowPropertyUseSearch &gt; BaseUseSearch</h2>
<p>Searches for the use of flow properties in other entities. Flow properties can be used in flows (in flow property factors) and unit groups (as default flow property).</p>
<h3 id="flowpropertyusesearch">FlowPropertyUseSearch()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>database : IDatabase</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="finduses-listcategorizeddescriptor-7">findUses() : List&lt;CategorizedDescriptor&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>ids : Set<Long></li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h2 id="flowusesearch-baseusesearch">FlowUseSearch &gt; BaseUseSearch</h2>
<p>Searches for the use of flows in other entities. Flows can be used in processes and impact methods.</p>
<h3 id="flowusesearch">FlowUseSearch()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>database : IDatabase</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="finduses-listcategorizeddescriptor-8">findUses() : List&lt;CategorizedDescriptor&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>ids : Set<Long></li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h2 id="iusesearch">IUseSearch</h2>
<p>Search of entities where another entity is used.</p>
<h3 id="factory-factory-1">FACTORY : Factory</h3>
<p><em>undocumented</em></p>
<h3 id="finduses-listcategorizeddescriptor-9">findUses() : List&lt;CategorizedDescriptor&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>id : long</li>
</ul>
<p>Returns a list of descriptors of entities where the given entity id is used.</p>
<h3 id="finduses-listcategorizeddescriptor-10">findUses() : List&lt;CategorizedDescriptor&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>entity : T</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="finduses-listcategorizeddescriptor-11">findUses() : List&lt;CategorizedDescriptor&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>entity : List<T></li>
</ul>
<p><em>undocumented</em></p>
<h3 id="finduses-listcategorizeddescriptor-12">findUses() : List&lt;CategorizedDescriptor&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>entity : Set<Long></li>
</ul>
<p><em>undocumented</em></p>
<h2 id="impactmethodusesearch-baseusesearch">ImpactMethodUseSearch &gt; BaseUseSearch</h2>
<p>Searches for the use of impact methods in other entities. Impact methods can be used in projects.</p>
<h3 id="impactmethodusesearch">ImpactMethodUseSearch()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>database : IDatabase</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="finduses-listcategorizeddescriptor-13">findUses() : List&lt;CategorizedDescriptor&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>ids : Set<Long></li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h2 id="locationusesearch-baseusesearch">LocationUseSearch &gt; BaseUseSearch</h2>
<p>Searches for the use of locations in other entities. Locations can be used in flows and processes.</p>
<h3 id="locationusesearch">LocationUseSearch()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>database : IDatabase</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="finduses-listcategorizeddescriptor-14">findUses() : List&lt;CategorizedDescriptor&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>ids : Set<Long></li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h2 id="parameterusagetree">ParameterUsageTree</h2>
<p>Calculates the usage tree for a parameter.</p>
<h3 id="parameterusagetree-1">ParameterUsageTree()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>param : String</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="nodes-list">nodes : List<Node></h3>
<p><em>undocumented</em></p>
<h3 id="param-string">param : String</h3>
<p><em>undocumented</em></p>
<h3 id="build-parameterusagetree">build() : ParameterUsageTree</h3>
<p><em>Parameters:</em></p>
<ul>
<li>param : String</li>
<li>db : IDatabase</li>
</ul>
<p><em>undocumented</em></p>
<h2 id="parameterusesearch-baseusesearch">ParameterUseSearch &gt; BaseUseSearch</h2>
<p>Searches for the use of parameters in other entities.</p>
<h3 id="parameterusesearch">ParameterUseSearch()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>database : IDatabase</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="finduses-listcategorizeddescriptor-15">findUses() : List&lt;CategorizedDescriptor&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>ids : Set<Long></li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h2 id="processusesearch-baseusesearch">ProcessUseSearch &gt; BaseUseSearch</h2>
<p>Searches for the use of processes in other entities. Processes can be used in product systems.</p>
<h3 id="processusesearch">ProcessUseSearch()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>database : IDatabase</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="finduses-listcategorizeddescriptor-16">findUses() : List&lt;CategorizedDescriptor&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>ids : Set<Long></li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h2 id="socialindicatorusesearch-baseusesearch">SocialIndicatorUseSearch &gt; BaseUseSearch</h2>
<p>Searches for the use of currencies in other entities. Currencies can be used in processes.</p>
<h3 id="socialindicatorusesearch">SocialIndicatorUseSearch()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>database : IDatabase</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="finduses-listcategorizeddescriptor-17">findUses() : List&lt;CategorizedDescriptor&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>ids : Set<Long></li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h2 id="sourceusesearch-baseusesearch">SourceUseSearch &gt; BaseUseSearch</h2>
<p>Searches for the use of sources in other entities. Sources can be used in processes.</p>
<h3 id="sourceusesearch">SourceUseSearch()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>database : IDatabase</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="finduses-listcategorizeddescriptor-18">findUses() : List&lt;CategorizedDescriptor&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>ids : Set<Long></li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h2 id="unitgroupusesearch-baseusesearch">UnitGroupUseSearch &gt; BaseUseSearch</h2>
<p>Searches for the use of unit groups in other entities. Unit groups can be used in flow properties.</p>
<h3 id="unitgroupusesearch">UnitGroupUseSearch()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>database : IDatabase</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="finduses-listcategorizeddescriptor-19">findUses() : List&lt;CategorizedDescriptor&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>ids : Set<Long></li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h2 id="unitusesearch">UnitUseSearch</h2>
<p>Searches for the usage of flow property factors of a given flow in other entities of the database.</p>
<h3 id="unitusesearch-1">UnitUseSearch()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>database : IDatabase</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="finduses-listcategorizeddescriptor-20">findUses() : List&lt;CategorizedDescriptor&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>unit : Unit</li>
</ul>
<p><em>undocumented</em></p>
<h1 id="package-org.openlca.core.math">Package: org.openlca.core.math</h1>
<h2 id="calculationsetup">CalculationSetup</h2>
<p>A setup for a product system calculation.</p>
<h3 id="calculationsetup-1">CalculationSetup()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>type : CalculationType</li>
<li>system : ProductSystem</li>
</ul>
<p>Creates a new calculation setup for the given type and product system. It does not add the parameter redefinitions of the product system to this setup. Thus, you need to do this in a separate step.</p>
<h3 id="allocationmethod-allocationmethod">allocationMethod : AllocationMethod</h3>
<p><em>undocumented</em></p>
<h3 id="impactmethod-impactmethoddescriptor">impactMethod : ImpactMethodDescriptor</h3>
<p><em>undocumented</em></p>
<h3 id="numberofruns-int">numberOfRuns : int</h3>
<p>Only valid for Monte Carlo Simulations</p>
<h3 id="nwset-nwsetdescriptor">nwSet : NwSetDescriptor</h3>
<p><em>undocumented</em></p>
<h3 id="parameterredefs-list">parameterRedefs : List<ParameterRedef></h3>
<p><em>undocumented</em></p>
<h3 id="productsystem-productsystem">productSystem : ProductSystem</h3>
<p><em>undocumented</em></p>
<h3 id="type-calculationtype">type : CalculationType</h3>
<p><em>undocumented</em></p>
<h3 id="withcosts-boolean">withCosts : boolean</h3>
<p><em>undocumented</em></p>
<h3 id="getamount-double">getAmount() : double</h3>
<p><em>undocumented</em></p>
<h3 id="getflowpropertyfactor-flowpropertyfactor">getFlowPropertyFactor() : FlowPropertyFactor</h3>
<p><em>undocumented</em></p>
<h3 id="getunit-unit">getUnit() : Unit</h3>
<p>Get the unit of the quantitative reference of the product system. By default this is the reference unit of the underlying product system.</p>
<h3 id="setamount-void">setAmount() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>amount : double</li>
</ul>
<p>Optionally set another target amount for the calculation than the one defined in the product system.</p>
<h3 id="setflowpropertyfactor-void">setFlowPropertyFactor() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>flowPropertyFactor : FlowPropertyFactor</li>
</ul>
<p>Optionally set another flow property factor for the calculation than the one defined in the product system.</p>
<h3 id="setunit-void">setUnit() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>unit : Unit</li>
</ul>
<p>Optionally set another unit for the calculation than the one defined in the product system.</p>
<h2 id="calculationtype">CalculationType</h2>
<p>The type of a calculation.</p>
<h3 id="simple_calculation">SIMPLE_CALCULATION</h3>
<p>Calculates the total results for elementary flows, LCIA indicators, costs, etc. of a product system.</p>
<h3 id="contribution_analysis">CONTRIBUTION_ANALYSIS</h3>
<p>Includes the total result vectors of a simple calculation but calculates also the direct contributions of each process (or better process product in case of multi-output processes) to these total results.</p>
<h3 id="upstream_analysis">UPSTREAM_ANALYSIS</h3>
<p>Extends the contribution analysis by providing also the upstream results of each process (process product) in the product system. The upstream result contains the direct contributions of the respective process but also the result of the supply chain up to this process scaled to the demand of the process in the product system.</p>
<h3 id="regionalized_calculation">REGIONALIZED_CALCULATION</h3>
<p>A regionalized calculation is a contribution analysis but with an LCIA method that supports regionalized characterization factors (via region specific parameters in formulas) and a product system with processes that have geographic information assigned (point, line, or polygon shapes).</p>
<h3 id="monte_carlo_simulation">MONTE_CARLO_SIMULATION</h3>
<p>A Monte Carlo simulation generates for each run, of a given number of a given number of iterations, random values according to the uncertainty distributions of process inputs/outputs, parameters, characterization factors, etc. of a product system and then performs a simple calculation for that specific run.</p>
<h2 id="datastructures">DataStructures</h2>
<p>Provides helper methods for creating matrix-like data structures that can be used in calculations (but also exports, validations, etc.).</p>
<h3 id="createproductindex-techindex">createProductIndex() : TechIndex</h3>
<p><em>Parameters:</em></p>
<ul>
<li>system : ProductSystem</li>
<li>db : IDatabase</li>
</ul>
<p>Creates a product index from the given product system.</p>
<h3 id="interpreter-formulainterpreter">interpreter() : FormulaInterpreter</h3>
<p><em>Parameters:</em></p>
<ul>
<li>db : IDatabase</li>
<li>setup : CalculationSetup</li>
<li>techIndex : TechIndex</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="matrixdata-matrixdata">matrixData() : MatrixData</h3>
<p><em>Parameters:</em></p>
<ul>
<li>setup : CalculationSetup</li>
<li>solver : IMatrixSolver</li>
<li>mcache : MatrixCache</li>
<li>subResults : Map&lt;ProcessProduct, SimpleResult&gt;</li>
</ul>
<p>Create the matrix data for the calculation of the given setup.</p>
<h3 id="parametercontexts-setlong">parameterContexts() : Set&lt;Long&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>setup : CalculationSetup</li>
<li>techIndex : TechIndex</li>
</ul>
<p><em>undocumented</em></p>
<h2 id="lcacalculator">LcaCalculator</h2>
<p>This calculator does the low level matrix based LCA-calculation. Typically, you do not want to use this directly but a more high level calculator where you can directly throw in a calculation setup or project.</p>
<h3 id="lcacalculator-1">LcaCalculator()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>solver : IMatrixSolver</li>
<li>data : MatrixData</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="calculatecontributions-contributionresult">calculateContributions() : ContributionResult</h3>
<p><em>undocumented</em></p>
<h3 id="calculatefull-fullresult">calculateFull() : FullResult</h3>
<p><em>undocumented</em></p>
<h3 id="calculatesimple-simpleresult">calculateSimple() : SimpleResult</h3>
<p><em>undocumented</em></p>
<h3 id="getloopfactor-double">getLoopFactor() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>A : IMatrix</li>
<li>s : double[]</li>
<li>techIndex : TechIndex</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="getrealdemands-double">getRealDemands() : double[]</h3>
<p><em>Parameters:</em></p>
<ul>
<li>totalRequirements : double[]</li>
<li>loopFactor : double</li>
</ul>
<p>Calculate the real demand vector for the analysis.</p>
<h3 id="getscalingvector-double">getScalingVector() : double[]</h3>
<p><em>Parameters:</em></p>
<ul>
<li>inverse : IMatrix</li>
<li>techIndex : TechIndex</li>
</ul>
<p>Calculates the scaling vector for the reference product i from the given inverse of the technology matrix:</p>
<p>s = d[i] .* Inverse[:, i]</p>
<p>where d is the demand vector and.</p>
<h3 id="gettotalrequirements-double">getTotalRequirements() : double[]</h3>
<p><em>Parameters:</em></p>
<ul>
<li>techMatrix : IMatrix</li>
<li>scalingVector : double[]</li>
</ul>
<p>Calculates the total requirements of the respective product amounts to fulfill the demand of the product system:</p>
<p>tr = s .* diag(A)</p>
<p>where s is the scaling vector and A the technology matrix.</p>
<h2 id="matrixrowsorter">MatrixRowSorter</h2>
<p>Sorts a <em>quadratic</em> matrix (the technology matrix in openLCA) so that rows with more entries are located at the bottom of the matrix.</p>
<h3 id="matrixrowsorter-1">MatrixRowSorter()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>original : IMatrix</li>
<li>solver : IMatrixSolver</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="run-imatrix">run() : IMatrix</h3>
<p><em>undocumented</em></p>
<h2 id="referenceamount">ReferenceAmount</h2>
<p>Functions for getting the reference amount. The reference amount is the amount of a flow value converted to the reference unit and flow property of that flow. This is the value that is used in the calculations.</p>
<h3 id="get-double">get() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>system : ProductSystem</li>
</ul>
<p>Get the reference amount of the reference flow / quantitative reference of the given product system.</p>
<h3 id="get-double-1">get() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>setup : CalculationSetup</li>
</ul>
<p>Get the reference amount of the reference flow / quantitative reference of the given calculation setup.</p>
<h3 id="get-double-2">get() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>e : Exchange</li>
</ul>
<p>Get the reference amount of the given exchange.</p>
<h2 id="simulator">Simulator</h2>
<p>A <code>Simulator</code> runs Monte-Carlo simulations with a given calculation setup.</p>
<p>When running the Monte Carlo simulation on a product system <span class="math inline">s_r</span> that has a sub-system (which again can have sub-systems etc.) we need to first run the number generation and calculation for that sub-system and integrate these results into the matrices of <span class="math inline">s_r</span> in each iteration step of the simulation. In general, we have to do this for each relation <span class="math inline">s_i \prec s_j</span>, where <span class="math inline">s_i</span> is a sub-system of <span class="math inline">s_j</span>, of all product systems <span class="math inline">S</span> of the recursively expanded sub-system dependencies.</p>
<p><span class="math inline">S</span> is a <a href="https://en.wikipedia.org/wiki/Partially_ordered_set#Strict_and_non-strict_partial_orders">strict partial ordered set</a> as we do not allow cycles in the sub-system dependencies. Thus, we can define a linear order of all systems via <a href="https://en.wikipedia.org/wiki/Topological_sorting">topological sorting</a> which maps each product system <span class="math inline">s_i</span> to a position <span class="math inline">pos_i</span> with <span class="math inline">pos_i &lt; pos_j</span> when <span class="math inline">s_i \prec s_j</span>.</p>
<p>In the simulation, we then run the number generation and calculation for each sub-system starting from the lowest position in <span class="math inline">pos = [1 \dots n]</span> where the top-most product system <span class="math inline">s_r</span> has the position <span class="math inline">pos_r = n</span>. Thus, in a simulation step a product system <span class="math inline">s_j</span> can access and integrate the result of a sub-system <span class="math inline">s_i</span> when <span class="math inline">s_i \prec s_j</span>. With this, the number generation and calculation have to be done only once for each simulation step for each product system <span class="math inline">s_i \in S</span>.</p>
<h3 id="pinnedproducts-set">pinnedProducts : Set<ProcessProduct></h3>
<p>A set of products for which upstream and direct contributions should be tracked during the simulation. These products must be part of the TechIndex.</p>
<h3 id="create-simulator">create() : Simulator</h3>
<p><em>Parameters:</em></p>
<ul>
<li>setup : CalculationSetup</li>
<li>mcache : MatrixCache</li>
<li>solver : IMatrixSolver</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="getenviindex-flowindex">getEnviIndex() : FlowIndex</h3>
<p><em>undocumented</em></p>
<h3 id="getimpactindex-dindeximpactcategorydescriptor">getImpactIndex() : DIndex&lt;ImpactCategoryDescriptor&gt;</h3>
<p><em>undocumented</em></p>
<h3 id="getresult-simulationresult">getResult() : SimulationResult</h3>
<p>Get the result of the simulation.</p>
<h3 id="gettechindex-techindex">getTechIndex() : TechIndex</h3>
<p><em>undocumented</em></p>
<h3 id="nextrun-simpleresult">nextRun() : SimpleResult</h3>
<p>Generates random numbers and calculates the product system. Returns the simulation result if the calculation in this run finished without errors, otherwise <code>null</code> is returned (e.g. when the resulting matrix was singular). The returned result is appended to the result of the simulator (which you get via <code>getResult()</code>, so it does not need to be cached.</p>
<h2 id="systemcalculator">SystemCalculator</h2>
<p>Calculates the results of a calculation setup or project. The same calculator can be used for different setups. The product systems of the setups may contain sub-systems. The calculator does not check if there are obvious errors like sub-system cycles etc.</p>
<h3 id="systemcalculator-1">SystemCalculator()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>cache : MatrixCache</li>
<li>solver : IMatrixSolver</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="calculate-projectresult">calculate() : ProjectResult</h3>
<p><em>Parameters:</em></p>
<ul>
<li>project : Project</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="calculatecontributions-contributionresult-1">calculateContributions() : ContributionResult</h3>
<p><em>Parameters:</em></p>
<ul>
<li>setup : CalculationSetup</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="calculatefull-fullresult-1">calculateFull() : FullResult</h3>
<p><em>Parameters:</em></p>
<ul>
<li>setup : CalculationSetup</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="calculatesimple-simpleresult-1">calculateSimple() : SimpleResult</h3>
<p><em>Parameters:</em></p>
<ul>
<li>setup : CalculationSetup</li>
</ul>
<p><em>undocumented</em></p>
<h1 id="package-org.openlca.core.math.data_quality">Package: org.openlca.core.math.data_quality</h1>
<h2 id="processingtype">ProcessingType</h2>
<p>Lists the different types of how to process n.a. values in data quality calculation</p>
<h3 id="exclude">EXCLUDE</h3>
<p><em>undocumented</em></p>
<h3 id="use_max">USE_MAX</h3>
<p><em>undocumented</em></p>
<h1 id="package-org.openlca.core.matrix">Package: org.openlca.core.matrix</h1>
<h2 id="allocationindex">AllocationIndex</h2>
<p>An instances of this class provides fast access to the allocation factors related to the products of a product system. It maps a product <span class="math inline">p</span> and an exchange of flow <span class="math inline">i</span> to the respective allocation factor <span class="math inline">\lambda_{p,i}</span>:</p>
<p><span class="math display">Idx_{Alloc}: (p, i) \mapsto \lambda_{p,i}</span></p>
<h3 id="create-allocationindex">create() : AllocationIndex</h3>
<p><em>Parameters:</em></p>
<ul>
<li>db : IDatabase</li>
<li>techIndex : TechIndex</li>
<li>method : AllocationMethod</li>
</ul>
<p>Creates a new allocation index for the given database, product index, and allocation method.</p>
<h3 id="get-double-3">get() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>product : ProcessProduct</li>
<li>exchangeID : long</li>
</ul>
<p>Returns the allocation factor <span class="math inline">\lambda_{p,i}</span> for the given product <span class="math inline">p</span> and (ID of the exchange with the) flow <span class="math inline">i</span>. <strong>It is very important</strong> that this method is only called with exchanges that can be allocated to a product output or waste input, which are: product inputs, waste outputs, or elementary flows.</p>
<h2 id="costvector">CostVector</h2>
<p>A cost vector contains the unscaled net-costs for a set of process-products. Unscaled means that these net-costs are related to the (allocated) product amount in the respective process. The vector is then scaled with the respective scaling factors in the result calculation.</p>
<h3 id="asmatrix-imatrix">asMatrix() : IMatrix</h3>
<p><em>Parameters:</em></p>
<ul>
<li>solver : IMatrixSolver</li>
<li>values : double[]</li>
</ul>
<p><em>undocumented</em></p>
<h2 id="dindex">DIndex</h2>
<p>Maps a set of descriptors to an ordinal, zero-based index of type int. This class is used to map descriptors to matrix columns. Note that this implementation assumes that the descriptors describe existing objects in a database and thus have an ID &gt; 0. Also, this class is <em>not</em> thread safe.</p>
<h3 id="at-d">at() : D</h3>
<p><em>Parameters:</em></p>
<ul>
<li>i : int</li>
</ul>
<p>Get the descriptor at the given position or null when there is no descriptor at the given position.</p>
<h3 id="contains-boolean">contains() : boolean</h3>
<p><em>Parameters:</em></p>
<ul>
<li>d : D</li>
</ul>
<p>Returns true when the given descriptor is part of that index.</p>
<h3 id="contains-boolean-1">contains() : boolean</h3>
<p><em>Parameters:</em></p>
<ul>
<li>id : long</li>
</ul>
<p>Returns true when the descriptor with the given ID is part of that index.</p>
<h3 id="content-setd">content() : Set&lt;D&gt;</h3>
<p>Returns the content of this index.</p>
<h3 id="each-void">each() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>fn : IndexConsumer<D></li>
</ul>
<p>Calls the given function for each descriptor in this index.</p>
<h3 id="idat-long">idAt() : long</h3>
<p><em>Parameters:</em></p>
<ul>
<li>i : int</li>
</ul>
<p>Get the ID of the descriptor at the given position.</p>
<h3 id="ids-long">ids() : long[]</h3>
<p>Get the IDs of all descriptors that are in this index.</p>
<h3 id="isempty-boolean">isEmpty() : boolean</h3>
<p>Returns true if there is no content in this index.</p>
<h3 id="of-int">of() : int</h3>
<p><em>Parameters:</em></p>
<ul>
<li>d : D</li>
</ul>
<p>Returns the position of the given descriptor. If the descriptor is not in the index, it returns -1.</p>
<h3 id="of-int-1">of() : int</h3>
<p><em>Parameters:</em></p>
<ul>
<li>id : long</li>
</ul>
<p>Returns the position of the descriptor with the given ID. If the descriptor is not in the index, it returns -1.</p>
<h3 id="put-int">put() : int</h3>
<p><em>Parameters:</em></p>
<ul>
<li>d : D</li>
</ul>
<p>Adds the given descriptor to this index if it is not yet contained and returns the index position of it.</p>
<h3 id="putall-void">putAll() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>it : Iterable<D></li>
</ul>
<p>Adds all descriptors from the given collection to this index.</p>
<h3 id="size-int">size() : int</h3>
<p>Returns the number of descriptors in the index.</p>
<h2 id="fastmatrixbuilder">FastMatrixBuilder</h2>
<p>A fast matrix builder that skips the product system linking layer …</p>
<h3 id="fastmatrixbuilder-1">FastMatrixBuilder()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>db : IDatabase</li>
<li>setup : CalculationSetup</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="build-matrixdata">build() : MatrixData</h3>
<p><em>undocumented</em></p>
<h2 id="flowindex-dindex">FlowIndex &gt; DIndex</h2>
<p>The row index <span class="math inline">\mathit{Idx}_B</span> of the intervention matrix <span class="math inline">\mathbf{B}</span>. It maps the (elementary) flows <span class="math inline">\mathit{F}</span> of the processes in the product system to the <span class="math inline">k</span> rows of <span class="math inline">\mathbf{B}</span>.</p>
<p><span class="math display">\mathit{Idx}_B: \mathit{F} \mapsto [0 \dots k-1]</span></p>
<h3 id="build-flowindex">build() : FlowIndex</h3>
<p><em>Parameters:</em></p>
<ul>
<li>cache : MatrixCache</li>
<li>productIndex : TechIndex</li>
<li>allocationMethod : AllocationMethod</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="isinput-boolean">isInput() : boolean</h3>
<p><em>Parameters:</em></p>
<ul>
<li>flow : FlowDescriptor</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="isinput-boolean-1">isInput() : boolean</h3>
<p><em>Parameters:</em></p>
<ul>
<li>flowId : long</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="putinput-int">putInput() : int</h3>
<p><em>Parameters:</em></p>
<ul>
<li>flow : FlowDescriptor</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="putoutput-int">putOutput() : int</h3>
<p><em>Parameters:</em></p>
<ul>
<li>flow : FlowDescriptor</li>
</ul>
<p><em>undocumented</em></p>
<h2 id="impactfactormatrix">ImpactFactorMatrix</h2>
<p>A matrix with impact assessment factors where the flows are mapped to the columns and the impact categories are mapped to the rows. The factors should be negative in this matrix if the corresponding flow is an input flow.</p>
<h3 id="impactfactormatrix-1">ImpactFactorMatrix()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>rows : int</li>
<li>columns : int</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="apply-void">apply() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>matrix : IMatrix</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="createrealmatrix-imatrix">createRealMatrix() : IMatrix</h3>
<p><em>Parameters:</em></p>
<ul>
<li>solver : IMatrixSolver</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="getentry-impactfactorcell">getEntry() : ImpactFactorCell</h3>
<p><em>Parameters:</em></p>
<ul>
<li>row : int</li>
<li>col : int</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="isempty-boolean-1">isEmpty() : boolean</h3>
<p><em>undocumented</em></p>
<h3 id="setentry-void">setEntry() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>row : int</li>
<li>col : int</li>
<li>cell : ImpactFactorCell</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="simulate-void">simulate() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>matrix : IMatrix</li>
</ul>
<p><em>undocumented</em></p>
<h2 id="impacttable">ImpactTable</h2>
<p>The ImpactTable is the corresponding data type to the Inventory type but wraps a matrix of impact assessment factors.</p>
<h3 id="factormatrix-impactfactormatrix">factorMatrix : ImpactFactorMatrix</h3>
<p><em>undocumented</em></p>
<h3 id="flowindex-flowindex">flowIndex : FlowIndex</h3>
<p><em>undocumented</em></p>
<h3 id="impactindex-dindex">impactIndex : DIndex<ImpactCategoryDescriptor></h3>
<p><em>undocumented</em></p>
<h3 id="build-impacttable">build() : ImpactTable</h3>
<p><em>Parameters:</em></p>
<ul>
<li>cache : MatrixCache</li>
<li>impactMethodId : long</li>
<li>flowIndex : FlowIndex</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="creatematrix-imatrix">createMatrix() : IMatrix</h3>
<p><em>Parameters:</em></p>
<ul>
<li>solver : IMatrixSolver</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="creatematrix-imatrix-1">createMatrix() : IMatrix</h3>
<p><em>Parameters:</em></p>
<ul>
<li>solver : IMatrixSolver</li>
<li>interpreter : FormulaInterpreter</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="isempty-boolean-2">isEmpty() : boolean</h3>
<p><em>undocumented</em></p>
<h3 id="simulate-void-1">simulate() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>matrix : IMatrix</li>
<li>interpreter : FormulaInterpreter</li>
</ul>
<p>Re-evaluates the parameters and formulas in the impact factor table (because they may changed), generates new values for the entries that have an uncertainty distribution and set these values to the entries of the given matrix. The given matrix and this impact table have to match exactly in size (so normally you first call createMatrix and than simulate).</p>
<h2 id="indexconsumer">IndexConsumer</h2>
<p>Like the normal consumer function but with an index of the respective object as first argument.</p>
<h3 id="accept-void">accept() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>index : int</li>
<li>obj : T</li>
</ul>
<p><em>undocumented</em></p>
<h2 id="inventoryconfig">InventoryConfig</h2>
<p>A class for configuration objects that are passed into an inventory builder.</p>
<h3 id="inventoryconfig-1">InventoryConfig()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>db : IDatabase</li>
<li>techIndex : TechIndex</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="allocationmethod-allocationmethod-1">allocationMethod : AllocationMethod</h3>
<p><em>undocumented</em></p>
<h3 id="db-idatabase">db : IDatabase</h3>
<p><em>undocumented</em></p>
<h3 id="interpreter-formulainterpreter-1">interpreter : FormulaInterpreter</h3>
<p><em>undocumented</em></p>
<h3 id="subresults-mapprocessproductsimpleresult">subResults : Map&lt;ProcessProduct,SimpleResult&gt;</h3>
<p>Optional sub-system results of the product system.</p>
<h3 id="techindex-techindex">techIndex : TechIndex</h3>
<p><em>undocumented</em></p>
<h3 id="withcosts-boolean-1">withCosts : boolean</h3>
<p><em>undocumented</em></p>
<h3 id="withuncertainties-boolean">withUncertainties : boolean</h3>
<p><em>undocumented</em></p>
<h2 id="linkingcallback">LinkingCallback</h2>
<p>A LinkingCallback is a function that can be injected into the creation of product systems links to control the linking process.</p>
<h3 id="cancel-boolean">cancel() : boolean</h3>
<p>Returns true if the linking process should be canceled.</p>
<h3 id="select-listprocessproduct">select() : List&lt;ProcessProduct&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>e : CalcExchange</li>
<li>providerCandidates : List<ProcessProduct></li>
</ul>
<p>This function is called when there are multiple possible providers for the given product input or waste output. The callback should select one or more providers from the given candidates. Returning null will lead to an undefined behavior. If exactly one provider is returned, the exchanges will be linked with this provider. When there are multiple providers returned, the linking process will select one option based on its own rules (e.g. this is what happens when the user selects <code>continue with auto-select</code> in the UI).</p>
<p>TODO: update doc</p>
<h2 id="longindex">LongIndex</h2>
<p>Maps arbitrary values of type long to an ordinal, zero-based index of type int. This class is used to map entity keys to matrix columns. The default value for a key that is not contained in this index is -1.</p>
<h3 id="contains-boolean-2">contains() : boolean</h3>
<p><em>Parameters:</em></p>
<ul>
<li>key : long</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="getindex-int">getIndex() : int</h3>
<p><em>Parameters:</em></p>
<ul>
<li>key : long</li>
</ul>
<p>Returns the index for the given key. Returns -1 if the key is not contained in the map.</p>
<h3 id="getkeyat-long">getKeyAt() : long</h3>
<p><em>Parameters:</em></p>
<ul>
<li>index : int</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="getkeys-long">getKeys() : long[]</h3>
<p>Get the keys of this index in their respective order in this index.</p>
<h3 id="isempty-boolean-3">isEmpty() : boolean</h3>
<p><em>undocumented</em></p>
<h3 id="put-int-1">put() : int</h3>
<p><em>Parameters:</em></p>
<ul>
<li>key : long</li>
</ul>
<p>Adds the given key to the index. The value for the key is the current size of the index.</p>
<h3 id="size-int-1">size() : int</h3>
<p>Returns the number of entries in the index.</p>
<h2 id="longpair-comparable">LongPair &gt; Comparable</h2>
<p>A LongPair saves just a pair of longs. We use this typically to efficiently store the IDs of a process and a product or waste flow as pair that we then use in indices to build matrix structures for the calculation. In this case, the first value should be always the process ID and the second the flow ID.</p>
<h3 id="longpair">LongPair()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>first : long</li>
<li>second : long</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="first-long">first : long</h3>
<p><em>undocumented</em></p>
<h3 id="second-long">second : long</h3>
<p><em>undocumented</em></p>
<h3 id="compareto-int">compareTo() : int</h3>
<p><em>Parameters:</em></p>
<ul>
<li>other : LongPair</li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h3 id="equals-boolean">equals() : boolean</h3>
<p><em>Parameters:</em></p>
<ul>
<li>first : long</li>
<li>second : long</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="equals-boolean-1">equals() : boolean</h3>
<p><em>Parameters:</em></p>
<ul>
<li>obj : Object</li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h3 id="hashcode-int">hashCode() : int</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="of-longpair">of() : LongPair</h3>
<p><em>Parameters:</em></p>
<ul>
<li>first : long</li>
<li>second : long</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="tostring-string">toString() : String</h3>
<p><em>Overridden method of supertype.</em></p>
<h2 id="matrixdata">MatrixData</h2>
<p>Contains the matrices of that are input of a calculation.</p>
<h3 id="costvector-double">costVector : double[]</h3>
<p>A cost vector contains the unscaled net-costs for a set of process-products. Unscaled means that these net-costs are related to the (allocated) product amount in the respective process. The vector is then scaled with the respective scaling factors in the result calculation. This vector is only available when LCC calculation should be done.</p>
<h3 id="enviindex-flowindex">enviIndex : FlowIndex</h3>
<p>The matrix index of the environmental/elementary flows (i.e. the row index of the intervention matrix; the column index of the impact matrix).</p>
<h3 id="envimatrix-imatrix">enviMatrix : IMatrix</h3>
<p>The intervention matrix.</p>
<h3 id="enviuncertainties-umatrix">enviUncertainties : UMatrix</h3>
<p>Contains the uncertainty distributions of the entries in the intervention matrix. This field is only used (not null) for uncertainty calculations.</p>
<h3 id="impactindex-dindex-1">impactIndex : DIndex<ImpactCategoryDescriptor></h3>
<p>The matrix index of the LCIA categories (i.e. the row index of the impact matrix).</p>
<h3 id="impactmatrix-imatrix">impactMatrix : IMatrix</h3>
<p>The matrix with the characterization factors: LCIA categories * elementary flows.</p>
<h3 id="techindex-techindex-1">techIndex : TechIndex</h3>
<p>The matrix index of the product and waste flows of the technosphere (i.e. the row and column index of the technology matrix; the column index of the intervention matrix).</p>
<h3 id="techmatrix-imatrix">techMatrix : IMatrix</h3>
<p>The technology matrix.</p>
<h3 id="techuncertainties-umatrix">techUncertainties : UMatrix</h3>
<p>Contains the uncertainty distributions of the entries in the technology matrix. This field is only used (not null) for uncertainty calculations.</p>
<h3 id="simulate-void-2">simulate() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>interpreter : FormulaInterpreter</li>
</ul>
<p><em>undocumented</em></p>
<h2 id="nwsettable">NwSetTable</h2>
<p>Stores the factors of a normalization and weighting set. As creating such a table is quite simple there is no separate builder class for reading this kind of data from a database but a factory method in this class.</p>
<h3 id="applyboth-listimpactresult">applyBoth() : List&lt;ImpactResult&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>results : List<ImpactResult></li>
</ul>
<p>Applies the normalization and weighting factors to the given impact assessment result. Returns a normalized and weighted result for each result item in the given list. The given list is not modified.</p>
<h3 id="applynormalisation-listimpactresult">applyNormalisation() : List&lt;ImpactResult&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>results : List<ImpactResult></li>
</ul>
<p>Applies the normalization factors to the given impact assessment result. Returns a normalized result for each result item in the given list. The given list is not modified.</p>
<h3 id="applyweighting-listimpactresult">applyWeighting() : List&lt;ImpactResult&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>results : List<ImpactResult></li>
</ul>
<p>Applies the weighting factors to the given impact assessment result. Returns a weighted result for each result item in the given list. The given list is not modified.</p>
<h3 id="build-nwsettable">build() : NwSetTable</h3>
<p><em>Parameters:</em></p>
<ul>
<li>database : IDatabase</li>
<li>nwSetId : long</li>
</ul>
<p>Builds the table by reading the factors for the NW-set with the given ID from the given database.</p>
<h3 id="getnormalisationfactor-double">getNormalisationFactor() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>impactCategoryId : long</li>
</ul>
<p>Get the normalization factor for the given LCIA category.</p>
<h3 id="getweightingfactor-double">getWeightingFactor() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>impactCategoryId : long</li>
</ul>
<p>Get the weighting factor for the given LCIA category.</p>
<h3 id="hasnormalisationfactors-boolean">hasNormalisationFactors() : boolean</h3>
<p><em>undocumented</em></p>
<h3 id="hasweightingfactors-boolean">hasWeightingFactors() : boolean</h3>
<p><em>undocumented</em></p>
<h2 id="parametertable">ParameterTable</h2>
<p>A data structure for fast creation of formula interpreters for the parameters of a database.</p>
<h3 id="forsimulation-parametertable">forSimulation() : ParameterTable</h3>
<p><em>Parameters:</em></p>
<ul>
<li>db : IDatabase</li>
<li>contexts : Set<Long></li>
<li>redefs : Collection<ParameterRedef></li>
</ul>
<p>Builds a parameter table suitable for creating formula interpreters in a Monte Carlo simulation.</p>
<h3 id="interpreter-formulainterpreter-2">interpreter() : FormulaInterpreter</h3>
<p><em>Parameters:</em></p>
<ul>
<li>db : IDatabase</li>
<li>contexts : Set<Long></li>
<li>redefs : Collection<ParameterRedef></li>
</ul>
<p>Builds a formula interpreter for the global parameters and the local parameters of the given contexts (processes or LCIA methods). It also applies the given parameter redefinitions.</p>
<h3 id="simulate-formulainterpreter">simulate() : FormulaInterpreter</h3>
<p>Calculates new random values for the parameters in this table that have an uncertainty distribution assigned. It re-binds the values of theses parameters in the underlying interpreter with the generated values.</p>
<h2 id="processlinksearchmap">ProcessLinkSearchMap</h2>
<p>This is a data structure for searching a set of existing process links by provider and recipient processes.</p>
<h3 id="processlinksearchmap-1">ProcessLinkSearchMap()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>links : Collection<ProcessLink></li>
</ul>
<p><em>undocumented</em></p>
<h3 id="getincominglinks-listprocesslink">getIncomingLinks() : List&lt;ProcessLink&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>processId : long</li>
</ul>
<p>Returns all incoming links to the process with the given ID, i.e. all links where the process is recipient.</p>
<h3 id="getlinks-listprocesslink">getLinks() : List&lt;ProcessLink&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>processId : long</li>
</ul>
<p>Returns all the links where the process with the given ID is either provider or recipient.</p>
<h3 id="getoutgoinglinks-listprocesslink">getOutgoingLinks() : List&lt;ProcessLink&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>processId : long</li>
</ul>
<p>Returns all the outgoing links from the process with the given ID, i.e. all links where the process is provider.</p>
<h2 id="processproduct">ProcessProduct</h2>
<p>In openLCA, we map the process-product pairs of a product system to the respective rows and columns of the matrices in the inventory model. Multi-output processes are split into multiple vectors that each are relate to a single process-product pair. This also includes waste treatment processes (where the treatment of waste is the product) and product systems that are sub-systems of other product systems (and are handled like processes in these systems with their quantitative reference as product).</p>
<h3 id="flow-flowdescriptor">flow : FlowDescriptor</h3>
<p>The product flow of the process-product pair. Note that this can also be a waste flow (which is then an input of the process and the treatment of waste is the product of the process).</p>
<h3 id="process-categorizeddescriptor">process : CategorizedDescriptor</h3>
<p>The process of process-product pair. Note that this can be also the descriptor of a product system when it is a sub-system of another product system because in this case such systems are handled just like processes (they are mapped to the technology matrix <span class="math inline">mathbf{A}</span> via the <code>TechIndex</code> etc.).</p>
<h3 id="equals-boolean-2">equals() : boolean</h3>
<p><em>Parameters:</em></p>
<ul>
<li>obj : Object</li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h3 id="flowid-long">flowId() : long</h3>
<p><em>undocumented</em></p>
<h3 id="hashcode-int-1">hashCode() : int</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="id-long">id() : long</h3>
<p>Returns the ID of the underlying process or product system of this provider.</p>
<h3 id="locationid-long">locationId() : Long</h3>
<p><em>undocumented</em></p>
<h3 id="of-processproduct">of() : ProcessProduct</h3>
<p><em>Parameters:</em></p>
<ul>
<li>entity : CategorizedDescriptor</li>
<li>flow : FlowDescriptor</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="of-processproduct-1">of() : ProcessProduct</h3>
<p><em>Parameters:</em></p>
<ul>
<li>process : Process</li>
<li>flow : Flow</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="of-processproduct-2">of() : ProcessProduct</h3>
<p><em>Parameters:</em></p>
<ul>
<li>system : ProductSystem</li>
</ul>
<p>Creates a product where the given product system is the provider and the reference flow of the system the product.</p>
<h3 id="pair-longpair">pair() : LongPair</h3>
<p><em>undocumented</em></p>
<h2 id="productsystembuilder">ProductSystemBuilder</h2>
<p>Builds or auto-completes a product system according to a given configuration.</p>
<h3 id="productsystembuilder-1">ProductSystemBuilder()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>matrixCache : MatrixCache</li>
<li>config : LinkingConfig</li>
</ul>
<p>Create a new product system builder.</p>
<h3 id="autocomplete-void">autoComplete() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>system : ProductSystem</li>
</ul>
<p>Auto-completes the given product system starting with the reference process of the system and following all product inputs and waste outputs recursively to link them to a provider process. After this function the product system will contain an updated set of process IDs and process links. The meta-data of the product system are not changed. When you then want to save these updated process IDs and process links in the database you can call the {<span class="citation" data-cites="link">@link</span> #saveLinks(ProductSystem)} function.</p>
<h3 id="autocomplete-void-1">autoComplete() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>system : ProductSystem</li>
<li>product : ProcessProduct</li>
</ul>
<p>Does the same as {<span class="citation" data-cites="link">@link</span> #autoComplete(ProductSystem)} but starts the linking at the given process product which can be arbitrary product in the supply chain of the given system.</p>
<h3 id="build-productsystem">build() : ProductSystem</h3>
<p><em>Parameters:</em></p>
<ul>
<li>process : Process</li>
</ul>
<p>Creates a new product system for the given process and runs the auto-complete functions with the linking configuration of this build. The returned system is not saved to the database.</p>
<h3 id="saveupdates-productsystem">saveUpdates() : ProductSystem</h3>
<p><em>Parameters:</em></p>
<ul>
<li>system : ProductSystem</li>
</ul>
<p>Saves the updated process links and IDs of the given product system in the databases. Note that if the product system is already contained in the database (i.e. has an ID &gt; 0) this function will not update the other meta-data of the system as it is intended to call this function after an {<span class="citation" data-cites="link">@link</span> #autoComplete(ProductSystem)} call in this case.</p>
<h2 id="techindex">TechIndex</h2>
<p>The index <span class="math inline">\mathit{Idx}_A</span> of the technology matrix <span class="math inline">\mathbf{A}</span> of a product system. It maps the process-product pairs (or process-waste pairs) <span class="math inline">\mathit{P}</span> of the product system to the respective <span class="math inline">n</span> rows and columns of <span class="math inline">\mathbf{A}</span>. If the product system contains other product systems as sub-systems, these systems are handled like processes and are also mapped as pair with their quantitative reference flow to that index (and also their processes etc.).</p>
<p><span class="math display">\mathit{Idx}_A: \mathit{P} \mapsto [0 \dots n-1]</span></p>
<h3 id="techindex-1">TechIndex()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>refFlow : ProcessProduct</li>
</ul>
<p>Creates a new technosphere index of a product system.</p>
<p><span class="citation" data-cites="param">@param</span> refFlow the reference product-output or waste-input as (processId, flowId) pair.</p>
<h3 id="contains-boolean-3">contains() : boolean</h3>
<p><em>Parameters:</em></p>
<ul>
<li>processID : long</li>
<li>flowID : long</li>
</ul>
<p>Returns true when there is a product in this index with a process and flow of the given IDs.</p>
<h3 id="content-setprocessproduct">content() : Set&lt;ProcessProduct&gt;</h3>
<p>Returns all providers of this index.</p>
<h3 id="each-void-1">each() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>fn : IndexConsumer<ProcessProduct></li>
</ul>
<p><em>undocumented</em></p>
<h3 id="getdemand-double">getDemand() : double</h3>
<p>The demand value. This is the amount of the reference flow given in the reference unit and flow property. The default value is 1.0.</p>
<h3 id="getindex-int-1">getIndex() : int</h3>
<p><em>Parameters:</em></p>
<ul>
<li>provider : ProcessProduct</li>
</ul>
<p>Returns the ordinal index of the given provider (product-output or waste input).</p>
<h3 id="getlinkedexchanges-setlongpair">getLinkedExchanges() : Set&lt;LongPair&gt;</h3>
<p>Returns all exchanges (product-inputs and waste-outputs) that are linked to provider of this index.</p>
<h3 id="getlinkedprovider-processproduct">getLinkedProvider() : ProcessProduct</h3>
<p><em>Parameters:</em></p>
<ul>
<li>exchange : LongPair</li>
</ul>
<p>Returns the linked provider (product-output or waste-input) for the given exchange (product-input or waste-output)</p>
<h3 id="getprocessids-setlong">getProcessIds() : Set&lt;Long&gt;</h3>
<p>Returns the IDs of all processes in this index (note that this can also can contain product system IDs if there are sub-systems in the product system).</p>
<h3 id="getprovider-processproduct">getProvider() : ProcessProduct</h3>
<p><em>Parameters:</em></p>
<ul>
<li>processID : long</li>
<li>flowID : long</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="getproviderat-processproduct">getProviderAt() : ProcessProduct</h3>
<p><em>Parameters:</em></p>
<ul>
<li>index : int</li>
</ul>
<p>Returns the provider (product-output or waste-input) at the given index.</p>
<h3 id="getproviders-listprocessproduct">getProviders() : List&lt;ProcessProduct&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>d : CategorizedDescriptor</li>
</ul>
<p>Get all providers with the given descriptor of a process or product system as entity.</p>
<h3 id="getproviders-listprocessproduct-1">getProviders() : List&lt;ProcessProduct&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>processId : long</li>
</ul>
<p>Returns the providers (product-outputs and waste-inputs) for the process with the given ID.</p>
<p>TODO: do we need this anymore?</p>
<h3 id="getrefflow-processproduct">getRefFlow() : ProcessProduct</h3>
<p>Get the reference product-output or waste-input of the product system described by this index.</p>
<h3 id="islinked-boolean">isLinked() : boolean</h3>
<p><em>Parameters:</em></p>
<ul>
<li>exchange : LongPair</li>
</ul>
<p>Returns true if the given product-input or waste-output is linked to a provider of this index.</p>
<h3 id="isprovider-boolean">isProvider() : boolean</h3>
<p><em>Parameters:</em></p>
<ul>
<li>processID : long</li>
</ul>
<p>Returns true when there is a process or product system with the given ID part of this index.</p>
<h3 id="put-void">put() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>provider : ProcessProduct</li>
</ul>
<p>Adds the given provider (product-output or waste-input) to this index. Does nothing if it is already contained in this index.</p>
<h3 id="putlink-void">putLink() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>exchange : LongPair</li>
<li>provider : ProcessProduct</li>
</ul>
<p>Adds a process link to this index.</p>
<p><span class="citation" data-cites="param">@param</span> exchange The linked product-input or waste-output as (processId, exchangeId) pair. <span class="citation" data-cites="param">@param</span> provider The product-output or waste-input (provider) as (processId, flowId) pair.</p>
<h3 id="setdemand-void">setDemand() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>demand : double</li>
</ul>
<p>The demand value. This is the amount of the reference flow given in the reference unit and flow property. The default value is 1.0.</p>
<h3 id="size-int-2">size() : int</h3>
<p>Returns the size of this index which is equal to the number of rows and columns in the related technology matrix.</p>
<h2 id="umatrix">UMatrix</h2>
<p>An UMatrix is a matrix with uncertainty distributions.</p>
<h3 id="umatrix-1">UMatrix()</h3>
<p><em>undocumented</em></p>
<h3 id="add-void">add() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>row : int</li>
<li>col : int</li>
<li>e : CalcExchange</li>
<li>allocationFactor : double</li>
</ul>
<p>Add the given Exchange to the uncertainty matrix. It is only added when it has an uncertainty distribution or formulas assigned. Thus, you should call this function for every exchange when building the inventory matrices as this function will decide whether an exchange should be added.</p>
<h3 id="generate-void">generate() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>m : IMatrix</li>
<li>interpreter : FormulaInterpreter</li>
</ul>
<p>Generates new values and sets them to the given matrix.</p>
<h1 id="package-org.openlca.core.matrix.cache">Package: org.openlca.core.matrix.cache</h1>
<h2 id="conversiontable">ConversionTable</h2>
<p>A table that contains the conversion factors for units and flow property factors. (Note: A flow can have multiple flow properties and a flow property factor describes the flow specific conversion of a flow property to the reference flow property of a flow).</p>
<h3 id="create-conversiontable">create() : ConversionTable</h3>
<p><em>Parameters:</em></p>
<ul>
<li>db : IDatabase</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="getcurrencyfactor-double">getCurrencyFactor() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>currencyID : long</li>
</ul>
<p>Get the conversion factor of the currency with the given ID to the reference currency in the database.</p>
<h3 id="getpropertyfactor-double">getPropertyFactor() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>flowPropertyFactorId : long</li>
</ul>
<p>Get the conversion factor of the given flow property factor to the reference flow property factor of a flow.</p>
<h3 id="getunitfactor-double">getUnitFactor() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>unitId : long</li>
</ul>
<p>Get the conversion factor of the unit with the given ID to the reference unit of the unit group to which this unit belongs.</p>
<h3 id="reload-void">reload() : void</h3>
<p><em>undocumented</em></p>
<h2 id="flowtable">FlowTable</h2>
<p>A simple data structure that holds the flow types of the flows in a database.</p>
<h3 id="create-flowtable">create() : FlowTable</h3>
<p><em>Parameters:</em></p>
<ul>
<li>database : IDatabase</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="get-flowdescriptor">get() : FlowDescriptor</h3>
<p><em>Parameters:</em></p>
<ul>
<li>flowID : long</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="getflowids-long">getFlowIds() : long[]</h3>
<p>Get the IDs of all flows in this table.</p>
<h3 id="gettypes-tlongobjecthashmapflowtype">getTypes() : TLongObjectHashMap&lt;FlowType&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>db : IDatabase</li>
</ul>
<p>Get a map with all <code>ID -&gt; FlowType</code> pairs from the database.</p>
<h3 id="reload-void-1">reload() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>db : IDatabase</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="type-flowtype">type() : FlowType</h3>
<p><em>Parameters:</em></p>
<ul>
<li>flowId : long</li>
</ul>
<p><em>undocumented</em></p>
<h2 id="processtable">ProcessTable</h2>
<p>TODO: tests + doc</p>
<h3 id="create-processtable">create() : ProcessTable</h3>
<p><em>Parameters:</em></p>
<ul>
<li>db : IDatabase</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="getprovider-processproduct-1">getProvider() : ProcessProduct</h3>
<p><em>Parameters:</em></p>
<ul>
<li>id : long</li>
<li>flowId : long</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="getproviders-listprocessproduct-2">getProviders() : List&lt;ProcessProduct&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>flowId : long</li>
</ul>
<p>Returns the list of providers that have the flow with the given ID as product output or waste input.</p>
<h3 id="getproviders-listprocessproduct-3">getProviders() : List&lt;ProcessProduct&gt;</h3>
<p>Get all product or waste treatment providers from the database.</p>
<h3 id="gettype-processtype">getType() : ProcessType</h3>
<p><em>Parameters:</em></p>
<ul>
<li>processId : long</li>
</ul>
<p>Returns the process type for the given process-ID.</p>
<h1 id="package-org.openlca.core.matrix.format">Package: org.openlca.core.matrix.format</h1>
<h2 id="ccrmatrix-imatrix">CCRMatrix &gt; IMatrix</h2>
<p>Implements a compressed-column representation of a sparse matrix. Note that this format is not editable. Calling <code>set(row, col, val)</code> will throw an exception.</p>
<h3 id="columnpointers-int">columnPointers : int[]</h3>
<p>The column pointers <span class="math inline">A.c</span> that indicate where each column begins. The last component of <span class="math inline">A.c</span> contains <span class="math inline">\text{nnz}(A)</span> where <span class="math inline">\text{nnz}(A)</span> is the number of non-zero entries in A.</p>
<h3 id="columns-int">columns : int</h3>
<p>The total number of columns.</p>
<h3 id="rowindices-int">rowIndices : int[]</h3>
<p>The row indices <span class="math inline">A.r</span> of the non-zero entries <span class="math inline">A.val</span>.</p>
<h3 id="rows-int">rows : int</h3>
<p>The total number of rows.</p>
<h3 id="values-double">values : double[]</h3>
<p>The vector with non-zero entries <span class="math inline">A.val</span>.</p>
<h3 id="columns-int-1">columns() : int</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="copy-imatrix">copy() : IMatrix</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="get-double-4">get() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>row : int</li>
<li>col : int</li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h3 id="getcolumn-double">getColumn() : double[]</h3>
<p><em>Parameters:</em></p>
<ul>
<li>i : int</li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h3 id="getrow-double">getRow() : double[]</h3>
<p><em>Parameters:</em></p>
<ul>
<li>i : int</li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h3 id="of-ccrmatrix">of() : CCRMatrix</h3>
<p><em>Parameters:</em></p>
<ul>
<li>other : IMatrix</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="rows-int-1">rows() : int</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="set-void">set() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>row : int</li>
<li>col : int</li>
<li>val : double</li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h3 id="setvalues-void">setValues() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>values : double[][]</li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h2 id="densematrix-imatrix">DenseMatrix &gt; IMatrix</h2>
<p>An implementation that uses a double precision array to store the data. Data are stored in column-major order.</p>
<h3 id="densematrix">DenseMatrix()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>rows : int</li>
<li>columns : int</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="columns-int-2">columns() : int</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="copy-densematrix">copy() : DenseMatrix</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="get-double-5">get() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>row : int</li>
<li>col : int</li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h3 id="getcolumn-double-1">getColumn() : double[]</h3>
<p><em>Parameters:</em></p>
<ul>
<li>i : int</li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h3 id="getdata-double">getData() : double[]</h3>
<p><em>undocumented</em></p>
<h3 id="getrow-double-1">getRow() : double[]</h3>
<p><em>Parameters:</em></p>
<ul>
<li>i : int</li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h3 id="rows-int-2">rows() : int</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="set-void-1">set() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>row : int</li>
<li>col : int</li>
<li>val : double</li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h2 id="hashpointmatrix-imatrix">HashPointMatrix &gt; IMatrix</h2>
<p>A sparse matrix implementation that uses primitive hash maps from the Trove project to store the data. Filling this matrix is fast with relatively low memory consumption.</p>
<p>Note that you have to make sure to set the respective row and column size when there are empty rows or columns.</p>
<h3 id="hashpointmatrix">HashPointMatrix()</h3>
<p><em>undocumented</em></p>
<h3 id="hashpointmatrix-1">HashPointMatrix()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>rows : int</li>
<li>cols : int</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="hashpointmatrix-2">HashPointMatrix()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>values : double[][]</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="cols-int">cols : int</h3>
<p><em>undocumented</em></p>
<h3 id="rows-int-3">rows : int</h3>
<p><em>undocumented</em></p>
<h3 id="clear-void">clear() : void</h3>
<p><em>undocumented</em></p>
<h3 id="columns-int-3">columns() : int</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="compress-compressedrowmatrix">compress() : CompressedRowMatrix</h3>
<p><em>undocumented</em></p>
<h3 id="copy-hashpointmatrix">copy() : HashPointMatrix</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="get-double-6">get() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>row : int</li>
<li>col : int</li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h3 id="getcolumn-double-2">getColumn() : double[]</h3>
<p><em>Parameters:</em></p>
<ul>
<li>i : int</li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h3 id="getnumberofentries-int">getNumberOfEntries() : int</h3>
<p><em>undocumented</em></p>
<h3 id="getrow-double-2">getRow() : double[]</h3>
<p><em>Parameters:</em></p>
<ul>
<li>i : int</li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h3 id="iterate-void">iterate() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>fn : EntryFunction</li>
</ul>
<p>Iterates over the non-zero values in this matrix.</p>
<h3 id="multiply-double">multiply() : double[]</h3>
<p><em>Parameters:</em></p>
<ul>
<li>v : double[]</li>
</ul>
<p>Performs a matrix-vector multiplication with the given vector v.</p>
<h3 id="rows-int-4">rows() : int</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="scalecolumns-void">scaleColumns() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>v : double[]</li>
</ul>
<p>Scales each column j of the matrix with the value v[j] of the given vector: M * diagm(v). The matrix is modified in-place.</p>
<h3 id="set-void-2">set() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>row : int</li>
<li>col : int</li>
<li>val : double</li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h3 id="tostring-string-1">toString() : String</h3>
<p><em>Overridden method of supertype.</em></p>
<h2 id="imatrix">IMatrix</h2>
<p>Interface with the general matrix operations used in openLCA.</p>
<h3 id="columns-int-4">columns() : int</h3>
<p>Returns the number of columns of the matrix.</p>
<h3 id="copy-imatrix-1">copy() : IMatrix</h3>
<p>Creates a copy of this matrix and returns it</p>
<h3 id="get-double-7">get() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>row : int</li>
<li>col : int</li>
</ul>
<p>Get the value of the given row and column.</p>
<h3 id="getcolumn-double-3">getColumn() : double[]</h3>
<p><em>Parameters:</em></p>
<ul>
<li>i : int</li>
</ul>
<p>Get the row values of the given column.</p>
<h3 id="getrow-double-3">getRow() : double[]</h3>
<p><em>Parameters:</em></p>
<ul>
<li>i : int</li>
</ul>
<p>Get the column values of the given row.</p>
<h3 id="rows-int-5">rows() : int</h3>
<p>Returns the number of rows of the matrix.</p>
<h3 id="set-void-3">set() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>row : int</li>
<li>col : int</li>
<li>val : double</li>
</ul>
<p>Set the entry in the given row and column to the given value.</p>
<h3 id="setvalues-void-1">setValues() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>values : double[][]</li>
</ul>
<p><em>undocumented</em></p>
<h2 id="matrixbuilder">MatrixBuilder</h2>
<p>This is matrix builder that allows you to create a matrix just by filling the values and which can switch efficiently between a sparse and dense representation during this filling process. It does this by allocation a growing dense matrix block and fast array copying if the fill rate exceeds a specific value. See https://github.com/msrocka/blockm for further information.</p>
<h3 id="matrixbuilder-1">MatrixBuilder()</h3>
<p><em>undocumented</em></p>
<h3 id="matrixbuilder-2">MatrixBuilder()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>maxSparseFileRate : double</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="matrixbuilder-3">MatrixBuilder()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>maxSparseFileRate : double</li>
<li>checkpoint : int</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="add-void-1">add() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>row : int</li>
<li>col : int</li>
<li>w : double</li>
</ul>
<p>Let <span class="math inline">v</span> be the current value at the cell $a_{row, col}. This function adds the given value <span class="math inline">w</span> to $a_{row, col} so that:</p>
<p><span class="math display">a_{row, col} = v + w</span></p>
<p>Where <span class="math inline">v = 0</span> When there is no value at $a_{row, col}.</p>
<h3 id="finish-imatrix">finish() : IMatrix</h3>
<p><em>undocumented</em></p>
<h3 id="minsize-void">minSize() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>rows : int</li>
<li>cols : int</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="set-void-4">set() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>row : int</li>
<li>col : int</li>
<li>val : double</li>
</ul>
<p>Set the cell (row, col) to the given value.</p>
<h2 id="sparsematrixdata-serializable">SparseMatrixData &gt; Serializable</h2>
<p>A class that holds the data of a sparse matrix. This class is only used for mapping the data between native and Java functions.</p>
<h3 id="sparsematrixdata">SparseMatrixData()</h3>
<p><em>undocumented</em></p>
<h3 id="sparsematrixdata-1">SparseMatrixData()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>matrix : HashPointMatrix</li>
</ul>
<p>Copies the data from the given matrix to a new instance of this class.</p>
<h3 id="columnindices-int">columnIndices : int[]</h3>
<p><em>undocumented</em></p>
<h3 id="columns-int-5">columns : int</h3>
<p><em>undocumented</em></p>
<h3 id="numberofentries-int">numberOfEntries : int</h3>
<p><em>undocumented</em></p>
<h3 id="rowindices-int-1">rowIndices : int[]</h3>
<p><em>undocumented</em></p>
<h3 id="rows-int-6">rows : int</h3>
<p><em>undocumented</em></p>
<h3 id="values-double-1">values : double[]</h3>
<p><em>undocumented</em></p>
<h1 id="package-org.openlca.core.matrix.io">Package: org.openlca.core.matrix.io</h1>
<h2 id="csvout">CsvOut</h2>
<p>This class provides methods for writing matrices and related indices to CSV files. It has the following properties:</p>
<ul>
<li>
existing files are overwritten
<li>
the column separator is a comma: <code>,</code>
<li>
the file encoding is <code>UTF-8</code>
<li>
the line separator is platform specific
<li>
internal exceptions are rethrown as runtime exceptions, handling them is up to you
</ul>
<h3 id="write-void">write() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>data : MatrixData</li>
<li>folder : File</li>
</ul>
<p>Write the given matrix data and indices as CSV files to the given folder.</p>
<h3 id="write-void-1">write() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>result : BaseResult</li>
<li>folder : File</li>
</ul>
<p>Write the result to the given folder.</p>
<h3 id="write-void-2">write() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>matrix : IMatrix</li>
<li>file : File</li>
</ul>
<p>Write the matrix to the given file.</p>
<h3 id="write-void-3">write() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>idx : TechIndex</li>
<li>file : File</li>
</ul>
<p>Write the product index into the given file.</p>
<h3 id="write-void-4">write() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>idx : FlowIndex</li>
<li>file : File</li>
</ul>
<p>Write the flow index into the given file.</p>
<h3 id="write-void-5">write() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>idx : DIndex<ImpactCategoryDescriptor></li>
<li>file : File</li>
</ul>
<p>Write the LCIA category index into the given file.</p>
<h3 id="writecol-void">writeCol() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>v : double[]</li>
<li>file : File</li>
</ul>
<p>Write the array as column vector to the given file.</p>
<h2 id="marketformatwriter">MarketFormatWriter</h2>
<p>Provides methods for writing matrices in the Matrix-Market format (see http://math.nist.gov/MatrixMarket/formats.html).</p>
<h3 id="marketformatwriter-1">MarketFormatWriter()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>file : File</li>
<li>matrix : IMatrix</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="writedense-void">writeDense() : void</h3>
Writes the matrix in array format:
<ol>
<li>
file header
</li>
<li>
[number of rows] [number of columns]
</li>
<li>
each entry in a separate row in column-major order
</li>
</ol>
<p>See the Matrix-Market format specification for more details.</p>
<h3 id="writesparse-void">writeSparse() : void</h3>
Writes the matrix in coordinate format:
<ol>
<li>
file header
</li>
<li>
[number of rows] [number of columns] [number of entries]
</li>
<li>
entries in the form: [row index] [column index] [value]
</li>
</ol>
<p>See the Matrix-Market format specification for more details.</p>
<h2 id="matbinmatrixreader">MatBinMatrixReader</h2>
<p>Reads a binary Matlab file (version?) with a matrix with 64 bit floating point numbers into a IMatrix.</p>
<h3 id="matbinmatrixreader-1">MatBinMatrixReader()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>file : File</li>
<li>solver : IMatrixSolver</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="read-imatrix">read() : IMatrix</h3>
<p><em>undocumented</em></p>
<h3 id="setusestreaming-void">setUseStreaming() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>useStreaming : boolean</li>
</ul>
<p><em>undocumented</em></p>
<h1 id="package-org.openlca.core.matrix.io.olcamat">Package: org.openlca.core.matrix.io.olcamat</h1>
<h2 id="enviindexentry">EnviIndexEntry</h2>
<p>Contains the meta-data of a row of the intervention matrix A.</p>
<h3 id="flowcategory-string">flowCategory : String</h3>
<p><em>undocumented</em></p>
<h3 id="flowid-string">flowID : String</h3>
<p><em>undocumented</em></p>
<h3 id="flowlocation-string">flowLocation : String</h3>
<p><em>undocumented</em></p>
<h3 id="flowname-string">flowName : String</h3>
<p><em>undocumented</em></p>
<h3 id="flowpropertyid-string">flowPropertyID : String</h3>
<p><em>undocumented</em></p>
<h3 id="flowpropertyname-string">flowPropertyName : String</h3>
<p><em>undocumented</em></p>
<h3 id="flowtype-flowtype">flowType : FlowType</h3>
<p><em>undocumented</em></p>
<h3 id="index-int">index : int</h3>
<p><em>undocumented</em></p>
<h3 id="unitid-string">unitID : String</h3>
<p><em>undocumented</em></p>
<h3 id="unitname-string">unitName : String</h3>
<p><em>undocumented</em></p>
<h3 id="clone-enviindexentry">clone() : EnviIndexEntry</h3>
<p><em>Overridden method of supertype.</em></p>
<h2 id="export-runnable">Export &gt; Runnable</h2>
<p>Exports a matrix into the openLCA matrix (=olcamat) format.The olcamat format is still experimental so this may change in future.</p>
<h3 id="export">Export()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>db : IDatabase</li>
<li>dir : File</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="export-1">Export()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>setup : CalculationSetup</li>
<li>db : IDatabase</li>
<li>dir : File</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="withresults-boolean">withResults : boolean</h3>
<p><em>undocumented</em></p>
<h3 id="run-void">run() : void</h3>
<p><em>Overridden method of supertype.</em></p>
<h2 id="techindexentry-enviindexentry">TechIndexEntry &gt; EnviIndexEntry</h2>
<p>Contains the meta-data of a row / column of the technology matrix A.</p>
<h3 id="processcategory-string">processCategory : String</h3>
<p><em>undocumented</em></p>
<h3 id="processid-string">processID : String</h3>
<p><em>undocumented</em></p>
<h3 id="processlocation-string">processLocation : String</h3>
<p><em>undocumented</em></p>
<h3 id="processname-string">processName : String</h3>
<p><em>undocumented</em></p>
<h3 id="processtype-processtype">processType : ProcessType</h3>
<p><em>undocumented</em></p>
<h3 id="clone-techindexentry">clone() : TechIndexEntry</h3>
<p><em>Overridden method of supertype.</em></p>
<h1 id="package-org.openlca.core.matrix.product.index">Package: org.openlca.core.matrix.product.index</h1>
<h2 id="providersearch">ProviderSearch</h2>
<p>Searches for the best provider for a given product input or waste output in the database.</p>
<h3 id="providersearch-1">ProviderSearch()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>processTable : ProcessTable</li>
<li>config : LinkingConfig</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="find-processproduct">find() : ProcessProduct</h3>
<p><em>Parameters:</em></p>
<ul>
<li>e : CalcExchange</li>
</ul>
<p>Find the best provider for the given product input or waste output according to the search settings.</p>
<h3 id="getlinkcandidates-listcalcexchange">getLinkCandidates() : List&lt;CalcExchange&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>list : List<CalcExchange></li>
</ul>
<p>Returns from the given list the product inputs or waste outputs that could be linked to a provider.</p>
<h1 id="package-org.openlca.core.matrix.solvers">Package: org.openlca.core.matrix.solvers</h1>
<h2 id="densesolver-imatrixsolver">DenseSolver &gt; IMatrixSolver</h2>
<p>A double precision solver that uses dense matrices and calls the respective</p>
<h3 id="invert-densematrix">invert() : DenseMatrix</h3>
<p><em>Parameters:</em></p>
<ul>
<li>a : IMatrix</li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h3 id="matrix-imatrix">matrix() : IMatrix</h3>
<p><em>Parameters:</em></p>
<ul>
<li>rows : int</li>
<li>columns : int</li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h3 id="multiply-double-1">multiply() : double[]</h3>
<p><em>Parameters:</em></p>
<ul>
<li>m : IMatrix</li>
<li>x : double[]</li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h3 id="multiply-densematrix">multiply() : DenseMatrix</h3>
<p><em>Parameters:</em></p>
<ul>
<li>a : IMatrix</li>
<li>b : IMatrix</li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h3 id="scalecolumns-void-1">scaleColumns() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>m : IMatrix</li>
<li>v : double[]</li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h3 id="solve-double">solve() : double[]</h3>
<p><em>Parameters:</em></p>
<ul>
<li>a : IMatrix</li>
<li>idx : int</li>
<li>d : double</li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h2 id="imatrixsolver">IMatrixSolver</h2>
<p>Interface for linear algebra and matrix problems that we need to solve in openLCA. We provide different implementations for these functions also in other packages which are based on high performance libraries like Eigen and OpenBLAS.</p>
<h3 id="invert-imatrix">invert() : IMatrix</h3>
<p><em>Parameters:</em></p>
<ul>
<li>a : IMatrix</li>
</ul>
<p>Calculates the inverse of the given matrix.</p>
<h3 id="matrix-imatrix-1">matrix() : IMatrix</h3>
<p><em>Parameters:</em></p>
<ul>
<li>rows : int</li>
<li>columns : int</li>
</ul>
<p>Creates an instance of the default matrix type that can be used with this solver.</p>
<h3 id="matrix-imatrix-2">matrix() : IMatrix</h3>
<p><em>Parameters:</em></p>
<ul>
<li>rows : int</li>
<li>columns : int</li>
<li>density : double</li>
</ul>
<p>Creates a instance of a matrix type which may dependent on the given density of the matrix (which is the number of non-zero elements divided by the total number of elements. By default it just calls the {<span class="citation" data-cites="link">@link</span> IMatrixSolver#matrix(int, int)} method but this can be overwritten when the solver supports dense and sparse matrix implementations.</p>
<h3 id="multiply-imatrix">multiply() : IMatrix</h3>
<p><em>Parameters:</em></p>
<ul>
<li>a : IMatrix</li>
<li>b : IMatrix</li>
</ul>
<p>Returns the matrix product of the given matrices.</p>
<h3 id="multiply-double-2">multiply() : double[]</h3>
<p><em>Parameters:</em></p>
<ul>
<li>m : IMatrix</li>
<li>v : double[]</li>
</ul>
<p>Calculates a matrix-vector product. In openLCA we use this for example when we calculate the inventory result: g = B * s</p>
<h3 id="scalecolumns-void-2">scaleColumns() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>m : IMatrix</li>
<li>v : double[]</li>
</ul>
<p>Scales the columns of matrix m with the factors in v. This is equivalent to m * diag(v) but can be implemented in a more efficient way.</p>
<h3 id="solve-double-1">solve() : double[]</h3>
<p><em>Parameters:</em></p>
<ul>
<li>a : IMatrix</li>
<li>idx : int</li>
<li>d : double</li>
</ul>
<p>Solves the system of linear equations A * s = d. In openLCA this is used to calculate the scaling factors of an inventory where the vector d has just a single entry.</p>
<p><span class="citation" data-cites="param">@param</span> a the technology matrix A <span class="citation" data-cites="param">@param</span> d the demand value (the entry in the vector d).</p>
<p><span class="citation" data-cites="param">@param</span> idx the index of the entry in the demand vector.</p>
<p><span class="citation" data-cites="return">@return</span> the calculated scaling vector s</p>
<h1 id="package-org.openlca.core.model">Package: org.openlca.core.model</h1>
<h2 id="abstractentity">AbstractEntity</h2>
<p>This is an abstract class for everything that is identified by an ID and can be stored in a database via JPA. Generally, the generation of the ID should be managed by JPA.</p>
<p>This class provides implementations for <code>hashCode</code> and <code>equals</code> that are based on the ID field.</p>
<h3 id="id-long-1">id : long</h3>
<p><em>undocumented</em></p>
<h3 id="equals-boolean-3">equals() : boolean</h3>
<p><em>Parameters:</em></p>
<ul>
<li>obj : Object</li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h3 id="hashcode-int-2">hashCode() : int</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="tostring-string-2">toString() : String</h3>
<p><em>Overridden method of supertype.</em></p>
<h2 id="actor-categorizedentity">Actor &gt; CategorizedEntity</h2>
<p>An actor can be a person or an organisation.</p>
<h3 id="address-string">address : String</h3>
<p><em>undocumented</em></p>
<h3 id="city-string">city : String</h3>
<p><em>undocumented</em></p>
<h3 id="country-string">country : String</h3>
<p><em>undocumented</em></p>
<h3 id="email-string">email : String</h3>
<p><em>undocumented</em></p>
<h3 id="telefax-string">telefax : String</h3>
<p><em>undocumented</em></p>
<h3 id="telephone-string">telephone : String</h3>
<p><em>undocumented</em></p>
<h3 id="website-string">website : String</h3>
<p><em>undocumented</em></p>
<h3 id="zipcode-string">zipCode : String</h3>
<p><em>undocumented</em></p>
<h3 id="clone-actor">clone() : Actor</h3>
<p><em>Overridden method of supertype.</em></p>
<h2 id="allocationfactor-abstractentity-cloneable">AllocationFactor &gt; AbstractEntity, Cloneable</h2>
<p>This type describes an allocation factor related to a product or waste flow of a multi-functional process. A multi-functional process has, in contrast to a mono-functional process, multiple product outputs, waste inputs, or both. Allocation factors can be used to transform a multi-functional process into a set of mono-functional processes (or more precisely into a set of mono-functional process vectors). This is done by splitting the amount <span class="math inline">m_{i,u}</span> of each product input, waste output, or elementary flow <span class="math inline">i</span> of the multi-functional process <span class="math inline">u</span> into a value <span class="math inline">m_{i,j}</span> for each product output or waste input <span class="math inline">j</span> by applying an allocation factor <span class="math inline">\lambda_{j}</span> respectively:</p>
<p><span class="math display">m_{i,j} = \lambda_{j} \ m_{i,u}</span></p>
<p>In openLCA, allocation factors for different allocation methods (physical, economic, causal allocation) can be stored for a process. While physical and economic allocation factors of a product <span class="math inline">j</span> are the same for all product inputs, waste outputs, or elementary flows <span class="math inline">i</span>, they can be different for each flow <span class="math inline">i</span> in case of causal allocation (so <span class="math inline">\lambda_{i,j}</span> in this case).</p>
<p>Furthermore, the value of an allocation factor is between 0 and 1, and the sum off all allocation factors related to each product <span class="math inline">j</span> (and flow <span class="math inline">i</span> in case of causal allocation) is 1:</p>
<p><span class="math display">0 \leq \lambda_{(i,)j} \leq 1 \ \text{and} \ \sum_j{\lambda_{(i,)j}} = 1</span></p>
<h3 id="exchange-exchange">exchange : Exchange</h3>
<p>If the factor is a causal allocation factor this field contains a reference to the exchange with flow <span class="math inline">i</span> to which the allocation factor is related. Note that there can be multiple exchanges with the same flow <span class="math inline">i</span> and different allocation factors.</p>
<h3 id="method-allocationmethod">method : AllocationMethod</h3>
<p>The allocation method to which the factor is related (physical, economic, or causal).</p>
<h3 id="productid-long">productId : long</h3>
<p>The ID of the product flow <span class="math inline">j</span> to which this allocation factor is related. In case of waste treatment processes (processes with waste inputs) this can be also the ID of a waste flow.</p>
<h3 id="value-double">value : double</h3>
<p>The value of the allocation factor <span class="math inline">\lambda_{j}</span> (or <span class="math inline">\lambda_{i,j}</span> in case of causal allocation).</p>
<h3 id="clone-allocationfactor">clone() : AllocationFactor</h3>
<p><em>Overridden method of supertype.</em></p>
<h2 id="allocationmethod">AllocationMethod</h2>
<p>An enumeration of the allocation methods that can be used in processes and calculation setups.</p>
<h3 id="use_default">USE_DEFAULT</h3>
<p>This is a flag, that is used for calculations only. It means that the respective default allocation method of a process should be used when building a product system. Note, that this is not a valid value for the default allocation method in a process.</p>
<h3 id="causal">CAUSAL</h3>
<p>Causal allocation means that the user can define an allocation factor for each input or output separately per output product of a process.</p>
<h3 id="economic">ECONOMIC</h3>
<p>Means that an economic flow property is used to calculate the allocation factors of a process.</p>
<h3 id="none">NONE</h3>
<p>Means that no allocation method should be used.</p>
<h3 id="physical">PHYSICAL</h3>
<p>Means that a physical flow property is used to calculate the allocation factors of a process.</p>
<h2 id="callback">Callback</h2>
<p>A simple callback interface for notification of model events; e.g. for imports and exports.</p>
<h3 id="apply-void-1">apply() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>message : Message</li>
<li>data : RootEntity</li>
</ul>
<p>Executes the callback function. This function follows the error-first pattern as known from Node.js but with a message object except of plain error.</p>
<h2 id="categorizedentity-rootentity">CategorizedEntity &gt; RootEntity</h2>
<p>A categorized entity is a root entity with a category.</p>
<h3 id="category-category">category : Category</h3>
<p><em>undocumented</em></p>
<h2 id="exchange-abstractentity">Exchange &gt; AbstractEntity</h2>
<p>Exchanges are representing the inputs and outputs of flows in processes.</p>
<h3 id="amount-double">amount : double</h3>
<p>The amount of the exchange.</p>
<h3 id="amountformula-string">amountFormula : String</h3>
<p>An optional formula for the exchange amount. The evaluated value of this formula should be always stored in the amount field.</p>
<h3 id="baseuncertainty-double">baseUncertainty : Double</h3>
<p>An optional base uncertainty of the data quality entry (= Pedigree matrix entry).</p>
<h3 id="costformula-string">costFormula : String</h3>
<p><em>undocumented</em></p>
<h3 id="costs-double">costs : Double</h3>
<p><em>undocumented</em></p>
<h3 id="currency-currency">currency : Currency</h3>
<p><em>undocumented</em></p>
<h3 id="defaultproviderid-long">defaultProviderId : long</h3>
<p>If the exchange is an product input or waste output this field can contain a process ID which produces the respective product or treats the waste flow. This field is used when processes are automatically linked in product system graphs. A value of zero means that no link is set.</p>
<h3 id="description-string">description : String</h3>
<p><em>undocumented</em></p>
<h3 id="dqentry-string">dqEntry : String</h3>
<p>The base uncertainty of the data quality entry (= Pedigree matrix entry).</p>
<h3 id="flow-flow">flow : Flow</h3>
<p>The flow of the exchange.</p>
<h3 id="flowpropertyfactor-flowpropertyfactor">flowPropertyFactor : FlowPropertyFactor</h3>
<p>The flow property (quantity) in which the amount of the exchange is given. It is a “flow property factor” because it contains also the conversion factor to the reference quantity of the flow.</p>
<h3 id="internalid-int">internalId : int</h3>
<p>An id that is unique within the process, this id must not be changed after creation</p>
<h3 id="isavoided-boolean">isAvoided : boolean</h3>
<p>Indicates whether an exchange is an avoided product or waste flow. An exchange with an avoided product flow must be set as an input and an avoided waste flow as an output in order to be handled correctly in the calculation.</p>
<h3 id="isinput-boolean-2">isInput : boolean</h3>
<p>Indicates whether the exchange is an input (= true) or output (= false).</p>
<h3 id="uncertainty-uncertainty">uncertainty : Uncertainty</h3>
<p>An optional uncertainty distribution of the exchange amount.</p>
<h3 id="unit-unit">unit : Unit</h3>
<p>The unit in which the exchange amount is given.</p>
<h3 id="clone-exchange">clone() : Exchange</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="from-exchange">from() : Exchange</h3>
<p><em>Parameters:</em></p>
<ul>
<li>flow : Flow</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="from-exchange-1">from() : Exchange</h3>
<p><em>Parameters:</em></p>
<ul>
<li>flow : Flow</li>
<li>property : FlowProperty</li>
<li>unit : Unit</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="tostring-string-3">toString() : String</h3>
<p><em>Overridden method of supertype.</em></p>
<h2 id="flowproperty-categorizedentity">FlowProperty &gt; CategorizedEntity</h2>
<p>Flow properties are quantities like mass, volume, etc.</p>
<h3 id="flowpropertytype-flowpropertytype">flowPropertyType : FlowPropertyType</h3>
<p><em>undocumented</em></p>
<h3 id="unitgroup-unitgroup">unitGroup : UnitGroup</h3>
<p><em>undocumented</em></p>
<h3 id="clone-flowproperty">clone() : FlowProperty</h3>
<p><em>Overridden method of supertype.</em></p>
<h2 id="flowpropertyfactor-abstractentity">FlowPropertyFactor &gt; AbstractEntity</h2>
<p>A conversion factor between two quantities of a flow.</p>
<h3 id="conversionfactor-double">conversionFactor : double</h3>
<p><em>undocumented</em></p>
<h3 id="flowproperty-flowproperty">flowProperty : FlowProperty</h3>
<p><em>undocumented</em></p>
<h3 id="clone-flowpropertyfactor">clone() : FlowPropertyFactor</h3>
<p><em>Overridden method of supertype.</em></p>
<h2 id="flowtype">FlowType</h2>
<p style="margin-top: 0">
Enumeration of available flow types
</p>
<h3 id="elementary_flow">ELEMENTARY_FLOW</h3>
<p><em>undocumented</em></p>
<h3 id="product_flow">PRODUCT_FLOW</h3>
<p><em>undocumented</em></p>
<h3 id="waste_flow">WASTE_FLOW</h3>
<p><em>undocumented</em></p>
<h2 id="mappingfile-abstractentity">MappingFile &gt; AbstractEntity</h2>
<p>A mapping file is used to store mappings of entities from other data formats (like ILCD, EcoSpold etc.) to openLCA entities or the other way around. See the olca-io module for the use of such mapping files in imports and exports. We just store the name of the file as string and its content as BLOB (which normally contains the compressed content).</p>
<h3 id="content-byte">content : byte[]</h3>
<p><em>undocumented</em></p>
<h3 id="filename-string">fileName : String</h3>
<p><em>undocumented</em></p>
<h2 id="modeltype">ModelType</h2>
<p>Enumeration of the basic types in the openLCA domain model.</p>
<h3 id="unknown">UNKNOWN</h3>
<p><em>undocumented</em></p>
<h3 id="project">PROJECT</h3>
<p><em>undocumented</em></p>
<h3 id="impact_method">IMPACT_METHOD</h3>
<p><em>undocumented</em></p>
<h3 id="impact_category">IMPACT_CATEGORY</h3>
<p><em>undocumented</em></p>
<h3 id="product_system">PRODUCT_SYSTEM</h3>
<p><em>undocumented</em></p>
<h3 id="process">PROCESS</h3>
<p><em>undocumented</em></p>
<h3 id="flow">FLOW</h3>
<p><em>undocumented</em></p>
<h3 id="flow_property">FLOW_PROPERTY</h3>
<p><em>undocumented</em></p>
<h3 id="unit_group">UNIT_GROUP</h3>
<p><em>undocumented</em></p>
<h3 id="unit">UNIT</h3>
<p><em>undocumented</em></p>
<h3 id="actor">ACTOR</h3>
<p><em>undocumented</em></p>
<h3 id="source">SOURCE</h3>
<p><em>undocumented</em></p>
<h3 id="category">CATEGORY</h3>
<p><em>undocumented</em></p>
<h3 id="location">LOCATION</h3>
<p><em>undocumented</em></p>
<h3 id="nw_set">NW_SET</h3>
<p><em>undocumented</em></p>
<h3 id="social_indicator">SOCIAL_INDICATOR</h3>
<p><em>undocumented</em></p>
<h3 id="currency">CURRENCY</h3>
<p><em>undocumented</em></p>
<h3 id="parameter">PARAMETER</h3>
<p><em>undocumented</em></p>
<h3 id="dq_system">DQ_SYSTEM</h3>
<p><em>undocumented</em></p>
<h3 id="categorized-modeltype">categorized() : ModelType[]</h3>
<p><em>undocumented</em></p>
<h3 id="formodelclass-modeltype">forModelClass() : ModelType</h3>
<p><em>Parameters:</em></p>
<ul>
<li>clazz : Class&lt;?&gt;</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="getmodelclass-class-extends-rootentity">getModelClass() : Class&lt;? extends RootEntity&gt;</h3>
<p><em>undocumented</em></p>
<h3 id="iscategorized-boolean">isCategorized() : boolean</h3>
<p><em>undocumented</em></p>
<h3 id="isoneof-boolean">isOneOf() : boolean</h3>
<p><em>Parameters:</em></p>
<ul>
<li>types : ModelType</li>
</ul>
<p><em>undocumented</em></p>
<h2 id="nwset-rootentity">NwSet &gt; RootEntity</h2>
<p>Normalization and weighting set.</p>
<h3 id="factors-list">factors : List<NwFactor></h3>
<p><em>undocumented</em></p>
<h3 id="weightedscoreunit-string">weightedScoreUnit : String</h3>
<p><em>undocumented</em></p>
<h3 id="clone-nwset">clone() : NwSet</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="getfactor-nwfactor">getFactor() : NwFactor</h3>
<p><em>Parameters:</em></p>
<ul>
<li>category : ImpactCategory</li>
</ul>
<p><em>undocumented</em></p>
<h2 id="parameter-categorizedentity">Parameter &gt; CategorizedEntity</h2>
<p>In openLCA, parameters can be defined in different scopes: global, process, or LCIA method. The parameter name can be used in formulas and, thus, need to conform to a specific syntax. Within a scope the parameter name should be unique (otherwise the evaluation is not deterministic). There are two types of parameters in openLCA: input parameters and dependent parameters. An input parameter can have an optional uncertainty distribution but not a formula. A dependent parameter can (should) have a formula (where also other parameters can be used) but no uncertainty distribution.</p>
<h3 id="externalsource-string">externalSource : String</h3>
<p>A reference to an external source of the parameter (e.g. a shape file in a regionalized LCIA method).</p>
<h3 id="formula-string">formula : String</h3>
<p>The formula of the parameter (only valid for dependent parameters).</p>
<h3 id="isinputparameter-boolean">isInputParameter : boolean</h3>
<p>Indicates whether the parameter is an input parameter.</p>
<h3 id="scope-parameterscope">scope : ParameterScope</h3>
<p>The scope of the parameter (global, process, LCIA method).</p>
<h3 id="sourcetype-string">sourceType : String</h3>
<p>If the parameter has an external source the type of this source can be specified in this field.</p>
<h3 id="uncertainty-uncertainty-1">uncertainty : Uncertainty</h3>
<p>The uncertainty distribution of the parameter value (only valid for input parameters).</p>
<h3 id="value-double-1">value : double</h3>
<p>The value of the parameter.</p>
<h3 id="clone-parameter">clone() : Parameter</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="isvalidname-boolean">isValidName() : boolean</h3>
<p><em>Parameters:</em></p>
<ul>
<li>name : String</li>
</ul>
<p>Returns true if the given name is a valid identifier for a parameter. We allow the same rules as for Java identifiers.</p>
<h3 id="tostring-string-4">toString() : String</h3>
<p><em>Overridden method of supertype.</em></p>
<h2 id="parameterredef-abstractentity">ParameterRedef &gt; AbstractEntity</h2>
<p>A redefinition of a parameter in a project or product systems. The redefinition defines a context for the redefinition which is the process or LCIA method for which the redefinition is valid. If there is no such context given it is a redefinition of a global parameter.</p>
<h3 id="contextid-long">contextId : Long</h3>
<p>The ID of the process or LCIA method for which the redefinition is valid. If the context ID is null it is a redefinition of a global parameter.</p>
<h3 id="contexttype-modeltype">contextType : ModelType</h3>
<p>The type of the context where the original parameter is defined (currently only processes or LCIA methods are possible). For global parameter redefinitions the context type is null.</p>
<h3 id="name-string">name : String</h3>
<p>The name of the parameter that should be redefined.</p>
<h3 id="uncertainty-uncertainty-2">uncertainty : Uncertainty</h3>
<p><em>undocumented</em></p>
<h3 id="value-double-2">value : double</h3>
<p><em>undocumented</em></p>
<h3 id="clone-parameterredef">clone() : ParameterRedef</h3>
<p><em>Overridden method of supertype.</em></p>
<h2 id="parameterscope">ParameterScope</h2>
<p>Parameters can be defined globally, in processes, or LCIA methods. They can be redefined in calculation setups on the project and product system level, but the initial definition is always only global, in processes, or LCIA methods.</p>
<h3 id="process-1">PROCESS</h3>
<p><em>undocumented</em></p>
<h3 id="impact_method-1">IMPACT_METHOD</h3>
<p><em>undocumented</em></p>
<h3 id="global">GLOBAL</h3>
<p><em>undocumented</em></p>
<h2 id="processdocumentation-abstractentity-cloneable">ProcessDocumentation &gt; AbstractEntity, Cloneable</h2>
<p>Contains the general documentation fields of a process that are not used for indexing, calculation, etc.</p>
<h3 id="completeness-string">completeness : String</h3>
<p><em>undocumented</em></p>
<h3 id="copyright-boolean">copyright : boolean</h3>
<p><em>undocumented</em></p>
<h3 id="creationdate-date">creationDate : Date</h3>
<p><em>undocumented</em></p>
<h3 id="datacollectionperiod-string">dataCollectionPeriod : String</h3>
<p><em>undocumented</em></p>
<h3 id="datadocumentor-actor">dataDocumentor : Actor</h3>
<p><em>undocumented</em></p>
<h3 id="datagenerator-actor">dataGenerator : Actor</h3>
<p><em>undocumented</em></p>
<h3 id="dataselection-string">dataSelection : String</h3>
<p><em>undocumented</em></p>
<h3 id="datasetowner-actor">dataSetOwner : Actor</h3>
<p><em>undocumented</em></p>
<h3 id="datatreatment-string">dataTreatment : String</h3>
<p><em>undocumented</em></p>
<h3 id="geography-string">geography : String</h3>
<p><em>undocumented</em></p>
<h3 id="intendedapplication-string">intendedApplication : String</h3>
<p><em>undocumented</em></p>
<h3 id="inventorymethod-string">inventoryMethod : String</h3>
<p><em>undocumented</em></p>
<h3 id="modelingconstants-string">modelingConstants : String</h3>
<p><em>undocumented</em></p>
<h3 id="precedingdataset-string">precedingDataSet : String</h3>
<p><em>undocumented</em></p>
<h3 id="project-string">project : String</h3>
<p><em>undocumented</em></p>
<h3 id="publication-source">publication : Source</h3>
<p><em>undocumented</em></p>
<h3 id="restrictions-string">restrictions : String</h3>
<p><em>undocumented</em></p>
<h3 id="reviewdetails-string">reviewDetails : String</h3>
<p><em>undocumented</em></p>
<h3 id="reviewer-actor">reviewer : Actor</h3>
<p><em>undocumented</em></p>
<h3 id="sampling-string">sampling : String</h3>
<p><em>undocumented</em></p>
<h3 id="sources-list">sources : List<Source></h3>
<p><em>undocumented</em></p>
<h3 id="technology-string">technology : String</h3>
<p><em>undocumented</em></p>
<h3 id="time-string">time : String</h3>
<p><em>undocumented</em></p>
<h3 id="validfrom-date">validFrom : Date</h3>
<p><em>undocumented</em></p>
<h3 id="validuntil-date">validUntil : Date</h3>
<p><em>undocumented</em></p>
<h3 id="clone-processdocumentation">clone() : ProcessDocumentation</h3>
<p><em>Overridden method of supertype.</em></p>
<h2 id="processgroup-comparable">ProcessGroup &gt; Comparable</h2>
<p>A group of process IDs with a name. The lower case name of the group is used as identifier for the equals, hash-code, and compare-functions.</p>
<h3 id="name-string-1">name : String</h3>
<p><em>undocumented</em></p>
<h3 id="processids-list">processIds : List<String></h3>
<p><em>undocumented</em></p>
<h3 id="compareto-int-1">compareTo() : int</h3>
<p><em>Parameters:</em></p>
<ul>
<li>o : ProcessGroup</li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h3 id="equals-boolean-4">equals() : boolean</h3>
<p><em>Parameters:</em></p>
<ul>
<li>obj : Object</li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h3 id="hashcode-int-3">hashCode() : int</h3>
<p><em>Overridden method of supertype.</em></p>
<h2 id="processgroupset-abstractentity">ProcessGroupSet &gt; AbstractEntity</h2>
<p>A set of process groups that can be stored in the database. The groups are stored in a binary format:</p>
<p>gzip(<a href="%5Bgroup_name%5D%5Bgroup_size:s%5D(%5Bprocess_id%5D)*s">number_of_groups:n</a>*n)</p>
<h3 id="name-string-2">name : String</h3>
<p><em>undocumented</em></p>
<h3 id="getgroups-listprocessgroup">getGroups() : List&lt;ProcessGroup&gt;</h3>
<p>Get the process groups from the internal byte array presentation.</p>
<h3 id="setgroups-void">setGroups() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>groups : List<ProcessGroup></li>
</ul>
<p>Sets the groups of this set by converting it to an internal byte array presentation.</p>
<h2 id="processlink-cloneable">ProcessLink &gt; Cloneable</h2>
<p>A process link is a connection between a provider (which can be a process or product system) and a process in a product system.</p>
<h3 id="exchangeid-long">exchangeId : long</h3>
<p>ID of the product input or waste output that is linked to a provider.</p>
<h3 id="flowid-long-1">flowId : long</h3>
<p>ID of the flow that is an output of the one process and an input of the of the other process.</p>
<h3 id="issystemlink-boolean">isSystemLink : boolean</h3>
<p>When true, the provider of this link is a product system.</p>
<h3 id="processid-long">processId : long</h3>
<p>ID of the process that has a link to the provider (has a product input or waste output).</p>
<h3 id="providerid-long">providerId : long</h3>
<p>ID of the process or product system that is an provider of a product (has a product output) or a waste treatment (has a waste input). The pair (providerId, flowId) is used to index the matrices in the calculation.</p>
<h3 id="clone-processlink">clone() : ProcessLink</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="equals-boolean-5">equals() : boolean</h3>
<p><em>Parameters:</em></p>
<ul>
<li>obj : Object</li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h3 id="hashcode-int-4">hashCode() : int</h3>
<p><em>Overridden method of supertype.</em></p>
<h2 id="rootentity-abstractentity-cloneable">RootEntity &gt; AbstractEntity, Cloneable</h2>
<p>A root entity is a stand alone entity in the application. It should have a name, description, and an UUID (reference ID). A root entity can contain other root entities via aggregation but the life cycle of the contained entities is then not coupled to the life cycle of the respective container (no cascade delete etc.). On the other side, the life cycle of non-root entities contained in root entities is coupled to the life cycle of the container.</p>
<p>Root entities must provide an implementation of <code>clone</code> with flat copies for contained root-entities and deep copies for contained non-root entities.</p>
<h3 id="description-string-1">description : String</h3>
<p><em>undocumented</em></p>
<h3 id="lastchange-long">lastChange : long</h3>
<p><em>undocumented</em></p>
<h3 id="name-string-3">name : String</h3>
<p><em>undocumented</em></p>
<h3 id="refid-string">refId : String</h3>
<p><em>undocumented</em></p>
<h3 id="version-long">version : long</h3>
<p><em>undocumented</em></p>
<h3 id="clone-object">clone() : Object</h3>
<p><em>undocumented</em></p>
<h3 id="tostring-string-5">toString() : String</h3>
<p><em>Overridden method of supertype.</em></p>
<h2 id="uncertainty">Uncertainty</h2>
<p>Represents the uncertainty distributions supported by openLCA. Three fields are reserved for distribution parameters. See the documentation of the respective fields to see which distribution parameters are stored in which fields for the respective distribution types. Each distribution parameter can take a value and additionally a formula.</p>
<h3 id="distributiontype-uncertaintytype">distributionType : UncertaintyType</h3>
<p><em>undocumented</em></p>
<h3 id="formula1-string">formula1 : String</h3>
<p>A formula for the first distribution parameter {<span class="citation" data-cites="link">@link</span> #parameter1}.</p>
<h3 id="formula2-string">formula2 : String</h3>
<p>A formula for the second distribution parameter {<span class="citation" data-cites="link">@link</span> #parameter2}.</p>
<h3 id="formula3-string">formula3 : String</h3>
<p>A formula for the third distribution parameter {<span class="citation" data-cites="link">@link</span> #parameter3}.</p>
<h3 id="parameter1-double">parameter1 : Double</h3>
The first parameter of the uncertainty distribution:
<ul>
<li>
Normal distribution: arithmetic mean value
<li>
Lognormal distribution: geometric mean value
<li>
Triangle distribution: min value
<li>
Uniform distribution: min value
<li>
None: mean / resulting amount
</ul>
<h3 id="parameter2-double">parameter2 : Double</h3>
The second parameter of the uncertainty distribution:
<ul>
<li>
Normal distribution: arithmetic standard deviation
<li>
Lognormal distribution: geometric standard deviation
<li>
Triangle distribution: most likely value (mode)
<li>
Uniform distribution: max value
</ul>
<h3 id="parameter3-double">parameter3 : Double</h3>
The third parameter of the uncertainty distribution:
<ul>
<li>
Triangle distribution: max value
</ul>
<h3 id="clone-uncertainty">clone() : Uncertainty</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="equals-boolean-6">equals() : boolean</h3>
<p><em>Parameters:</em></p>
<ul>
<li>obj : Object</li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h3 id="fromstring-uncertainty">fromString() : Uncertainty</h3>
<p><em>Parameters:</em></p>
<ul>
<li>s : String</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="generator-numbergenerator">generator() : NumberGenerator</h3>
<p>Creates a number generator of this uncertainty distribution.</p>
<h3 id="hashcode-int-5">hashCode() : int</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="lognormal-uncertainty">logNormal() : Uncertainty</h3>
<p><em>Parameters:</em></p>
<ul>
<li>gmean : double</li>
<li>gsd : double</li>
</ul>
<p>Creates a log-normal distribution.</p>
<p><span class="citation" data-cites="param">@param</span> gmean the geometric mean. <span class="citation" data-cites="param">@param</span> gsd the geometric standard deviation</p>
<h3 id="none-uncertainty">none() : Uncertainty</h3>
<p><em>Parameters:</em></p>
<ul>
<li>mean : double</li>
</ul>
<p>Creates default distribution with type set to NONE and the first parameter set with the given mean value.</p>
<h3 id="normal-uncertainty">normal() : Uncertainty</h3>
<p><em>Parameters:</em></p>
<ul>
<li>mean : double</li>
<li>sd : double</li>
</ul>
<p>Creates a normal distribution.</p>
<p><span class="citation" data-cites="param">@param</span> mean the arithmetic mean. <span class="citation" data-cites="param">@param</span> sd the arithmetic standard deviation.</p>
<h3 id="scale-void">scale() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>factor : double</li>
</ul>
<p>Scales the distribution parameters by the given factor. This multiplies every distribution parameter with the given factor. Except for the geometric standard deviation in log-normal distributions as this parameter is scale independent.</p>
<h3 id="string-string">string() : String</h3>
<p><em>Parameters:</em></p>
<ul>
<li>u : Uncertainty</li>
</ul>
<p>A null-save method for getting the string representation of an uncertainty distribution.</p>
<h3 id="tostring-string-6">toString() : String</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="triangle-uncertainty">triangle() : Uncertainty</h3>
<p><em>Parameters:</em></p>
<ul>
<li>min : double</li>
<li>mode : double</li>
<li>max : double</li>
</ul>
<p>Creates a triangle distribution.</p>
<p><span class="citation" data-cites="param">@param</span> min The minimum value. <span class="citation" data-cites="param">@param</span> mode The most likely value (the mode). <span class="citation" data-cites="param">@param</span> max The maximum value.</p>
<h3 id="uniform-uncertainty">uniform() : Uncertainty</h3>
<p><em>Parameters:</em></p>
<ul>
<li>min : double</li>
<li>max : double</li>
</ul>
<p>Creates a uniform distribution.</p>
<p><span class="citation" data-cites="param">@param</span> min the minimum. <span class="citation" data-cites="param">@param</span> max the maximum.</p>
<h2 id="unitgroup-categorizedentity">UnitGroup &gt; CategorizedEntity</h2>
<p>A set of {<span class="citation" data-cites="link">@link</span> Unit} objects which are directly convertible into each other (e.g. units of mass: kg, g, mg…). A unit set has a reference unit with the conversion factor 1.0. The respective conversion factor of the other units is defined by the equation: f = [uRef] / [u] (with f: the conversion factor of the respective unit, [uRef] the equivalent amount in the reference unit, [u] the equivalent amount in the respective unit; e.g. f(kg) = 1.0 -&gt; f(g) = 0.001).</p>
<h3 id="defaultflowproperty-flowproperty">defaultFlowProperty : FlowProperty</h3>
<p><em>undocumented</em></p>
<h3 id="referenceunit-unit">referenceUnit : Unit</h3>
<p><em>undocumented</em></p>
<h3 id="units-list">units : List<Unit></h3>
<p><em>undocumented</em></p>
<h3 id="clone-unitgroup">clone() : UnitGroup</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="getunit-unit-1">getUnit() : Unit</h3>
<p><em>Parameters:</em></p>
<ul>
<li>name : String</li>
</ul>
<p>Returns the unit with the specified name or synonym from this group.</p>
<h2 id="version">Version</h2>
<p>A helper class for handling versions of root entities in openLCA. We support the following version scheme major.minor.update but store the parts of the version number in a single field. This makes the version number easy to compare, automatically increment (the update part), and can be converted to the ILCD and ecoinvent version schemes.</p>
<p>For each version field we allow a value between 0 and 32767 so the minimum version number is 0.0.0 and the maximum number 32767.32767.32767. The exact data type for a version field would be a 2-byte positive integer (short). However, we use integers in the public methods of this class to avoid casting.</p>
<h3 id="version-1">Version()</h3>
<p><em>undocumented</em></p>
<h3 id="version-2">Version()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>value : long</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="version-3">Version()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>major : int</li>
<li>minor : int</li>
<li>update : int</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="asstring-string">asString() : String</h3>
<p><em>Parameters:</em></p>
<ul>
<li>version : long</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="equals-boolean-7">equals() : boolean</h3>
<p><em>Parameters:</em></p>
<ul>
<li>obj : Object</li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h3 id="fromstring-version">fromString() : Version</h3>
<p><em>Parameters:</em></p>
<ul>
<li>s : String</li>
</ul>
<p>Returns the version from the given string. The string can be an ILCD compatible version string with 3 parts (major.minor.update, e.g. 01.01.000) where the two last parts and leading zeros are optional. Thus valid version strings are for example: 1, 1.1, 01.01.001, 44.1.96</p>
<h3 id="getmajor-int">getMajor() : int</h3>
<p><em>undocumented</em></p>
<h3 id="getminor-int">getMinor() : int</h3>
<p><em>undocumented</em></p>
<h3 id="getupdate-int">getUpdate() : int</h3>
<p><em>undocumented</em></p>
<h3 id="getvalue-long">getValue() : long</h3>
<p><em>undocumented</em></p>
<h3 id="hashcode-int-6">hashCode() : int</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="incmajor-void">incMajor() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>entity : RootEntity</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="incmajor-void-1">incMajor() : void</h3>
<p>Increments the major part of the version which resets the minor and update part to 0.</p>
<h3 id="incminor-void">incMinor() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>entity : RootEntity</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="incminor-void-1">incMinor() : void</h3>
<p>Increments the minor part of the version which resets the update part to 0.</p>
<h3 id="incupdate-void">incUpdate() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>entity : RootEntity</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="incupdate-void-1">incUpdate() : void</h3>
<p>Increments the update part of the version. Normally this is automatically done by the persistence unit.</p>
<h3 id="setmajor-void">setMajor() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>major : int</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="setminor-void">setMinor() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>minor : int</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="setupdate-void">setUpdate() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>update : int</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="tostring-string-7">toString() : String</h3>
<p>Converts the version to an ILCD compatible version string with 3 parts: major.minor.update.</p>
<h3 id="valueof-long">valueOf() : long</h3>
<p><em>Parameters:</em></p>
<ul>
<li>major : int</li>
<li>minor : int</li>
<li>update : int</li>
</ul>
<p><em>undocumented</em></p>
<h1 id="package-org.openlca.core.model.descriptors">Package: org.openlca.core.model.descriptors</h1>
<h2 id="basedescriptor">BaseDescriptor</h2>
<p>Descriptors are lightweight models containing only descriptive information of a corresponding entity.The intention of descriptors is to get these information fast from the database without loading the complete model. Therefore, the respective DAO classes should provide these.</p>
<h3 id="description-string-2">description : String</h3>
<p><em>undocumented</em></p>
<h3 id="id-long-2">id : long</h3>
<p><em>undocumented</em></p>
<h3 id="lastchange-long-1">lastChange : long</h3>
<p><em>undocumented</em></p>
<h3 id="name-string-4">name : String</h3>
<p><em>undocumented</em></p>
<h3 id="refid-string-1">refId : String</h3>
<p><em>undocumented</em></p>
<h3 id="type-modeltype">type : ModelType</h3>
<p><em>undocumented</em></p>
<h3 id="version-long-1">version : long</h3>
<p><em>undocumented</em></p>
<h3 id="equals-boolean-8">equals() : boolean</h3>
<p><em>Parameters:</em></p>
<ul>
<li>obj : Object</li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h3 id="hashcode-int-7">hashCode() : int</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="tostring-string-8">toString() : String</h3>
<p><em>Overridden method of supertype.</em></p>
<h2 id="impactcategorydescriptor-basedescriptor">ImpactCategoryDescriptor &gt; BaseDescriptor</h2>
<p>The descriptor class for impact assessment categories.</p>
<h3 id="impactcategorydescriptor">ImpactCategoryDescriptor()</h3>
<p><em>undocumented</em></p>
<h3 id="referenceunit-string">referenceUnit : String</h3>
<p><em>undocumented</em></p>
<h2 id="impactmethoddescriptor-categorizeddescriptor">ImpactMethodDescriptor &gt; CategorizedDescriptor</h2>
<p>The descriptor class for impact assessment methods.</p>
<h3 id="impactmethoddescriptor">ImpactMethodDescriptor()</h3>
<p><em>undocumented</em></p>
<h1 id="package-org.openlca.core.results">Package: org.openlca.core.results</h1>
<h2 id="baseresult-iresult">BaseResult &gt; IResult</h2>
<p><code>BaseResult</code> is a common (abstract) super class of different result implementations. It mainly contains the indices that map objects from the database to the rows and columns of the result matrices.</p>
<h3 id="flowindex-flowindex-1">flowIndex : FlowIndex</h3>
<p>The row index <span class="math inline">\mathit{Idx}_B</span> of the intervention matrix <span class="math inline">\mathbf{B}</span>. It maps the (elementary) flows <span class="math inline">\mathit{F}</span> of the processes in the product system to the <span class="math inline">k</span> rows of <span class="math inline">\mathbf{B}</span>.</p>
<p><span class="math display">\mathit{Idx}_B: \mathit{F} \mapsto [0 \dots k-1]</span></p>
<h3 id="impactindex-dindex-2">impactIndex : DIndex<ImpactCategoryDescriptor></h3>
<p>The row index <span class="math inline">\mathit{Idx}_C</span> of the matrix with the characterization factors <span class="math inline">\mathbf{C}</span>. It maps the LCIA categories <span class="math inline">\mathit{C}</span> to the <span class="math inline">l</span> rows of <span class="math inline">\mathbf{C}</span>.</p>
<p><span class="math display">\mathit{Idx}_C: \mathit{C} \mapsto [0 \dots l-1]</span></p>
<h3 id="techindex-techindex-2">techIndex : TechIndex</h3>
<p>The index <span class="math inline">\mathit{Idx}_A</span> of the technology matrix <span class="math inline">\mathbf{A}</span>. It maps the process-product pairs (or process-waste pairs) <span class="math inline">\mathit{P}</span> of the product system to the respective <span class="math inline">n</span> rows and columns of <span class="math inline">\mathbf{A}</span>. If the product system contains other product systems as sub-systems, these systems are handled like processes and are also mapped as pair with their quantitative reference flow to that index (and also their processes etc.).</p>
<p><span class="math display">\mathit{Idx}_A: \mathit{P} \mapsto [0 \dots n-1]</span></p>
<h3 id="getflows-setflowdescriptor">getFlows() : Set&lt;FlowDescriptor&gt;</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="getimpacts-setimpactcategorydescriptor">getImpacts() : Set&lt;ImpactCategoryDescriptor&gt;</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="getprocesses-setcategorizeddescriptor">getProcesses() : Set&lt;CategorizedDescriptor&gt;</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="getproviders-setprocessproduct">getProviders() : Set&lt;ProcessProduct&gt;</h3>
<p>Get the process-product pairs (or process-waste pairs) <span class="math inline">\mathit{P}</span> of the product system. If the product system contains other product systems as sub-systems, these systems are handled like processes and are also included as pairs with their quantitative reference flow.</p>
<h3 id="hasflowresults-boolean">hasFlowResults() : boolean</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="hasimpactresults-boolean">hasImpactResults() : boolean</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="isinput-boolean-3">isInput() : boolean</h3>
<p><em>Parameters:</em></p>
<ul>
<li>flow : FlowDescriptor</li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h2 id="contributionresult-simpleresult">ContributionResult &gt; SimpleResult</h2>
<p>The <code>ContributionResult</code> extends the <code>SimpleResult</code> type. It also contains all direct contributions of the processes to the LCI and LCIA results. Additionally, it contains the contributions of the (elementary) flows to the LCIA results.</p>
<h3 id="directcostresults-double">directCostResults : double[]</h3>
<p>Contains the direct contributions <span class="math inline">\mathbf{k}_s</span> of the process-product pairs to the total net-costs (<span class="math inline">\odot</span> denotes element-wise multiplication):</p>
<p><span class="math display">\mathbf{k}_s = \mathbf{k} \odot \mathbf{s}</span></p>
<h3 id="directflowimpacts-imatrix">directFlowImpacts : IMatrix</h3>
<p>A LCIA category * flow matrix that contains the direct contributions of the elementary flows to the LCIA result. This matrix can be calculated by column-wise scaling of the matrix with the characterization factors <span class="math inline">\mathbf{C}</span> with the inventory result <span class="math inline">\mathbf{g}</span>:</p>
<p><span class="math display">\mathbf{H} = \mathbf{C} \ \text{diag}(\mathbf{g})</span></p>
<h3 id="directflowresults-imatrix">directFlowResults : IMatrix</h3>
<p>An elementary flow * process-product matrix that contains the direct contributions of the processes to the inventory result. This can be calculated by column-wise scaling of the intervention matrix <span class="math inline">\mathbf{B}</span> with the scaling vector <span class="math inline">\mathbf{s}</span>:</p>
<p><span class="math display">\mathbf{G} = \mathbf{B} \ \text{diag}(\mathbf{s})</span></p>
<h3 id="directimpactresults-imatrix">directImpactResults : IMatrix</h3>
<p>A LCIA category * process-product matrix that contains the direct contributions of the processes to the LCIA result. This can be calculated by a matrix-matrix multiplication of the direct inventory contributions <span class="math inline">\mathbf{G}</span> with the matrix with the characterization factors <span class="math inline">\mathbf{C}</span>:</p>
<p><span class="math display">\mathbf{H} = \mathbf{C} \ \mathbf{G}</span></p>
<h3 id="impactfactors-imatrix">impactFactors : IMatrix</h3>
<p>A LCIA category * flow matrix <span class="math inline">\mathbf{C}</span> the contains the characterization factors.</p>
<h3 id="getdirectcostresult-double">getDirectCostResult() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>product : ProcessProduct</li>
</ul>
<p>Get the direct contribution of the given process-product pair <span class="math inline">j</span> to the LCC result: <span class="math inline">\mathbf{k}_s[j]</span>.</p>
<h3 id="getdirectcostresult-double-1">getDirectCostResult() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>process : CategorizedDescriptor</li>
</ul>
<p>Get the direct contribution of the given process <span class="math inline">j</span> to the LCC result. When the process has multiple products it is the sum of the contributions of all of these process-product pairs.</p>
<h3 id="getdirectflowimpact-double">getDirectFlowImpact() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>flow : FlowDescriptor</li>
<li>impact : ImpactCategoryDescriptor</li>
</ul>
<p>Get the direct contribution of the given elementary flow to the LCIA result of the given LCIA category.</p>
<h3 id="getdirectflowresult-double">getDirectFlowResult() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>product : ProcessProduct</li>
<li>flow : FlowDescriptor</li>
</ul>
<p>Get the direct contribution of the given process-product pair <span class="math inline">j</span> to the inventory result of elementary flow <span class="math inline">i</span>: <span class="math inline">\mathbf{G}[i,j]</span>.</p>
<h3 id="getdirectflowresult-double-1">getDirectFlowResult() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>process : CategorizedDescriptor</li>
<li>flow : FlowDescriptor</li>
</ul>
<p>Get the direct contribution of the given process <span class="math inline">j</span> to the inventory result of elementary flow <span class="math inline">i</span>. When the process has multiple products it is the sum of the contributions of all of these process-product pairs.</p>
<h3 id="getdirectimpactresult-double">getDirectImpactResult() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>product : ProcessProduct</li>
<li>impact : ImpactCategoryDescriptor</li>
</ul>
<p>Get the direct contribution of the given process-product pair <span class="math inline">j</span> to the LCIA category result <span class="math inline">j</span>: <span class="math inline">\mathbf{D}[i,j]</span>.</p>
<h3 id="getdirectimpactresult-double-1">getDirectImpactResult() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>process : CategorizedDescriptor</li>
<li>impact : ImpactCategoryDescriptor</li>
</ul>
<p>Get the direct contribution of the given process <span class="math inline">j</span> to the LCIA category result <span class="math inline">i</span>. When the process has multiple products it is the sum of the contributions of all of these process-product pairs.</p>
<h3 id="getflowcontributions-listflowresult">getFlowContributions() : List&lt;FlowResult&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>process : CategorizedDescriptor</li>
</ul>
<p>Get the direct contributions of the given process <span class="math inline">j</span> to the inventory result of all elementary flows in the product system.</p>
<h3 id="getflowcontributions-listflowresult-1">getFlowContributions() : List&lt;FlowResult&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>impact : ImpactCategoryDescriptor</li>
</ul>
<p>Get the contributions of all elementary flows to the given LCA category.</p>
<h3 id="getimpactcontributions-listimpactresult">getImpactContributions() : List&lt;ImpactResult&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>process : CategoryDescriptor</li>
</ul>
<p>Get the direct contributions of the given process <span class="math inline">j</span> to the LCIA category results.</p>
<h3 id="getprocesscontributions-contributionsetcategorizeddescriptor">getProcessContributions() : ContributionSet&lt;CategorizedDescriptor&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>flow : FlowDescriptor</li>
</ul>
<p>Get the direct contributions of the processes in the system to the inventory result of the given flow.</p>
<h3 id="getprocesscontributions-contributionsetcategorizeddescriptor-1">getProcessContributions() : ContributionSet&lt;CategorizedDescriptor&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>impact : ImpactCategoryDescriptor</li>
</ul>
<p>Get the direct contributions of the processes in the system to the LCIA result of the given LCIA category.</p>
<h3 id="getprocesscostcontributions-contributionsetcategorizeddescriptor">getProcessCostContributions() : ContributionSet&lt;CategorizedDescriptor&gt;</h3>
<p>Get the direct contributions of all processes to the LCC result.</p>
<h3 id="hascostresults-boolean">hasCostResults() : boolean</h3>
<p><em>Overridden method of supertype.</em></p>
<h2 id="contributionset">ContributionSet</h2>
<p>A set of contributions to an overall result.</p>
<h3 id="contributionset-1">ContributionSet()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>contributions : List&lt;ContributionItem<T>&gt;</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="contributions-listcontributionitem">contributions : List&lt;ContributionItem<T>&gt;</h3>
<p><em>undocumented</em></p>
<h3 id="empty-contributionsett">empty() : ContributionSet&lt;T&gt;</h3>
<p><em>undocumented</em></p>
<h3 id="getcontribution-contributionitemt">getContribution() : ContributionItem&lt;T&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>item : T</li>
</ul>
<p><em>undocumented</em></p>
<h2 id="fullresult-contributionresult">FullResult &gt; ContributionResult</h2>
<p>The <code>FullResult</code> extends the <code>ContributionResult</code>. It contains additionally the upstream contributions to LCI, LCIA, and LCC results where applicable.</p>
<h3 id="loopfactor-double">loopFactor : double</h3>
<p>The loop factor <span class="math inline">c_r</span> indicates whether the reference process of the product system is part of a product loop (<span class="math inline">c_r \neq 1</span> when this is the case). It can be calculated via:</p>
<p><span class="math display">c_r = \frac{\mathbf{s}[r] \mathbf{A}[r,r]}{\mathbf{f}[r]}</span></p>
<p>Where <span class="math inline">r</span> is the index of the reference product of the system. Some upstream results have to be corrected by <span class="math inline">c_r</span> when <span class="math inline">c_r \neq 1</span> to avoid double counting of these loop contributions.</p>
<h3 id="techmatrix-imatrix-1">techMatrix : IMatrix</h3>
<p>The <em>scaled</em> technology matrix <span class="math inline">\mathbf{A*}</span> of the product system. In this matrix each column <span class="math inline">j</span> is scaled by the respective scaling factor <span class="math inline">\mathbf{s}_j</span>:</p>
<p><span class="math display">\mathbf{A*} = \mathbf{A} \ \text{diag}(\mathbf{s})</span></p>
<h3 id="upstreamcostresults-imatrix">upstreamCostResults : IMatrix</h3>
<p>A row vector the upstream contributions to the LCC result of each process-product pair in the product system.</p>
<p><span class="math display">\mathbf{k}_u = (\mathbf{k} \ \mathbf{A}^{-1}) \ \text{diag}(c_r \ \mathbf{t})</span></p>
<p>When the reference process itself is located in a loop the total requirements need to be multiplied with the loop factor <span class="math inline">c_r</span> to avoid double counting of the loop contributions (as they are contained in <span class="math inline">\mathbf{A}^{-1}</span> and <span class="math inline">\mathbf{t}</span>).</p>
<h3 id="upstreamflowresults-imatrix">upstreamFlowResults : IMatrix</h3>
<p>An elementary flow * process-product matrix that contains the upstream contributions (including the direct contributions) of the processes to the inventory result. It can be calculated by column-wise scaling of the result of the matrix-matrix multiplication of the intervention matrix <span class="math inline">\mathbf{B}</span> with the inverse of the technology matrix <span class="math inline">\mathbf{A}</span> by the total requirements <span class="math inline">\mathbf{t}</span>:</p>
<p><span class="math display">\mathbf{U} = (\mathbf{B} \ \mathbf{A}^{-1}) \ \text{diag}(c_r \ \mathbf{t})</span></p>
<p>When the reference process itself is located in a loop the total requirements need to be multiplied with the loop factor <span class="math inline">c_r</span> to avoid double counting of the loop contributions (as they are contained in <span class="math inline">\mathbf{A}^{-1}</span> and <span class="math inline">\mathbf{t}</span>).</p>
<h3 id="upstreamimpactresults-imatrix">upstreamImpactResults : IMatrix</h3>
<p>A LCIA category * process-product matrix that contains the upstream contributions (including the direct contributions) of the processes to the LCIA result. It can be calculated by a matrix-matrix multiplication of the characterization factor matrix <span class="math inline">\mathbf{C}</span> with the upstream results of the elementary flows <span class="math inline">\mathbf{U}</span>:</p>
<p><span class="math display">\mathbf{V} = \mathbf{C} \ \mathbf{U}</span></p>
<h3 id="getaddedvaluetree-upstreamtree">getAddedValueTree() : UpstreamTree</h3>
<p>Calculate the upstream tree for the LCC result as added value.</p>
<h3 id="getcosttree-upstreamtree">getCostTree() : UpstreamTree</h3>
<p>Calculate the upstream tree for the LCC result as costs.</p>
<h3 id="getlinkshare-double">getLinkShare() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>link : ProcessLink</li>
</ul>
<p>Get the contribution share of the outgoing process product (provider) to the product input (recipient) of the given link and the calculated product system. The returned share is a value between 0 and 1.</p>
<h3 id="gettree-upstreamtree">getTree() : UpstreamTree</h3>
<p><em>Parameters:</em></p>
<ul>
<li>flow : FlowDescriptor</li>
</ul>
<p>Calculate the upstream tree for the given flow.</p>
<h3 id="gettree-upstreamtree-1">getTree() : UpstreamTree</h3>
<p><em>Parameters:</em></p>
<ul>
<li>impact : ImpactCategoryDescriptor</li>
</ul>
<p>Calculate the upstream tree for the given LCIA category.</p>
<h3 id="getupstreamcostresult-double">getUpstreamCostResult() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>provider : ProcessProduct</li>
</ul>
<p>Get the upstream contribution of the given process-product pair <span class="math inline">j</span> to the LCC result: <span class="math inline">\mathbf{k}_u[j]</span>.</p>
<h3 id="getupstreamcostresult-double-1">getUpstreamCostResult() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>process : CategorizedDescriptor</li>
</ul>
<p>Get the upstream contribution of the given process <span class="math inline">j</span> to the LCC result. When the process has multiple products it is the sum of the contributions of all of these process-product pairs.</p>
<h3 id="getupstreamflowresult-double">getUpstreamFlowResult() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>product : ProcessProduct</li>
<li>flow : FlowDescriptor</li>
</ul>
<p>Get the upstream contribution of the given process-product pair <span class="math inline">j</span> to the inventory result of elementary flow <span class="math inline">i</span>: <span class="math inline">\mathbf{U}[i,j]</span>.</p>
<h3 id="getupstreamflowresult-double-1">getUpstreamFlowResult() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>process : CategorizedDescriptor</li>
<li>flow : FlowDescriptor</li>
</ul>
<p>Get the upstream contribution of the given process <span class="math inline">j</span> to the inventory result of elementary flow <span class="math inline">i</span>. When the process has multiple products it is the sum of the contributions of all of these process-product pairs.</p>
<h3 id="getupstreamflowresults-listflowresult">getUpstreamFlowResults() : List&lt;FlowResult&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>process : CategorizedDescriptor</li>
</ul>
<p>Get the upstream contributions of the given process <span class="math inline">j</span> to the inventory result of all elementary flows in the product system.</p>
<h3 id="getupstreamimpactresult-double">getUpstreamImpactResult() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>product : ProcessProduct</li>
<li>impact : ImpactCategoryDescriptor</li>
</ul>
<p>Get the upstream contribution of the given process-product pair <span class="math inline">j</span> to the LCIA category result <span class="math inline">j</span>: <span class="math inline">\mathbf{V}[i,j]</span>.</p>
<h3 id="getupstreamimpactresult-double-1">getUpstreamImpactResult() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>process : CategorizedDescriptor</li>
<li>impact : ImpactCategoryDescriptor</li>
</ul>
<p>Get the upstream contribution of the given process <span class="math inline">j</span> to the LCIA category result <span class="math inline">i</span>. When the process has multiple products it is the sum of the contributions of all of these process-product pairs.</p>
<h3 id="getupstreamimpactresults-listimpactresult">getUpstreamImpactResults() : List&lt;ImpactResult&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>process : CategorizedDescriptor</li>
</ul>
<p>Get the upstream contributions of the given process <span class="math inline">j</span> to the LCIA category results.</p>
<h2 id="groupingcontribution">GroupingContribution</h2>
<p>Calculates the contributions of single process results grouped by a given grouping set.</p>
<h3 id="groupingcontribution-1">GroupingContribution()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>result : ContributionResult</li>
<li>groupings : List<ProcessGrouping></li>
</ul>
<p><em>undocumented</em></p>
<h3 id="calculate-contributionsetprocessgrouping">calculate() : ContributionSet&lt;ProcessGrouping&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>flow : FlowDescriptor</li>
</ul>
<p>Calculates contributions to an inventory flow.</p>
<h3 id="calculate-contributionsetprocessgrouping-1">calculate() : ContributionSet&lt;ProcessGrouping&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>impact : ImpactCategoryDescriptor</li>
</ul>
<p>Calculates contributions to an impact assessment method.</p>
<h2 id="iresult">IResult</h2>
<p>The common protocol of all result types.</p>
<h3 id="getflows-setflowdescriptor-1">getFlows() : Set&lt;FlowDescriptor&gt;</h3>
<p>Get the (elementary) flows of the inventory model.</p>
<h3 id="getimpacts-setimpactcategorydescriptor-1">getImpacts() : Set&lt;ImpactCategoryDescriptor&gt;</h3>
<p>Get the LCIA categories of the LCIA result.</p>
<h3 id="getprocesses-setcategorizeddescriptor-1">getProcesses() : Set&lt;CategorizedDescriptor&gt;</h3>
<p>Get the descriptors of the processes of the inventory model. If a product system contains other product systems, these sub-systems are also handled like processes and returned.</p>
<h3 id="hascostresults-boolean-1">hasCostResults() : boolean</h3>
<p>Returns true when this result contains LCC results.</p>
<h3 id="hasflowresults-boolean-1">hasFlowResults() : boolean</h3>
<p>Returns true when this result contains (elementary) flow results.</p>
<h3 id="hasimpactresults-boolean-1">hasImpactResults() : boolean</h3>
<p>Returns true when this result contains LCIA results.</p>
<h3 id="isinput-boolean-4">isInput() : boolean</h3>
<p><em>Parameters:</em></p>
<ul>
<li>flow : FlowDescriptor</li>
</ul>
<p>Returns true when the given flow is handled as an input flow in the inventory model.</p>
<h2 id="locationcontribution">LocationContribution</h2>
<p>Calculates the contributions of the single process results in an analysis result grouped by their locations.</p>
<h3 id="locationcontribution-1">LocationContribution()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>result : ContributionResult</li>
<li>cache : EntityCache</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="addedvalues-contributionsetlocation">addedValues() : ContributionSet&lt;Location&gt;</h3>
<p>Calculates added values aggregated by location.</p>
<h3 id="calculate-contributionsetlocation">calculate() : ContributionSet&lt;Location&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>flow : FlowDescriptor</li>
</ul>
<p>Calculates contributions to an inventory flow.</p>
<h3 id="calculate-contributionsetlocation-1">calculate() : ContributionSet&lt;Location&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>impact : ImpactCategoryDescriptor</li>
</ul>
<p>Calculates contributions to an impact category.</p>
<h3 id="netcosts-contributionsetlocation">netCosts() : ContributionSet&lt;Location&gt;</h3>
<p>Calculates net-costs aggregated by location.</p>
<h2 id="processgrouping">ProcessGrouping</h2>
<p>A group of processes for result analysis. If this group is tagged as rest it contains all processes that are not assigned to other groups.</p>
<h3 id="name-string-5">name : String</h3>
<p><em>undocumented</em></p>
<h3 id="processes-list">processes : List<CategorizedDescriptor></h3>
<p><em>undocumented</em></p>
<h3 id="rest-boolean">rest : boolean</h3>
<p><em>undocumented</em></p>
<h3 id="applyon-listprocessgrouping">applyOn() : List&lt;ProcessGrouping&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>processes : Collection<CategorizedDescriptor></li>
<li>groupSet : ProcessGroupSet</li>
<li>restName : String</li>
</ul>
<p>Applies the given group set on the given processes. If there are processes not assignable to a group of the group set a group with these processes is created using the given parameter restName.</p>
<h3 id="equals-boolean-9">equals() : boolean</h3>
<p><em>Parameters:</em></p>
<ul>
<li>obj : Object</li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h3 id="hashcode-int-8">hashCode() : int</h3>
<p><em>Overridden method of supertype.</em></p>
<h2 id="projectresult-iresult">ProjectResult &gt; IResult</h2>
<p>A project result is a wrapper for the inventory results of the respective project variants.</p>
<h3 id="addresult-void">addResult() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>variant : ProjectVariant</li>
<li>result : ContributionResult</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="getcontributions-contributionsetprojectvariant">getContributions() : ContributionSet&lt;ProjectVariant&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>flow : FlowDescriptor</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="getcontributions-contributionsetprojectvariant-1">getContributions() : ContributionSet&lt;ProjectVariant&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>impact : ImpactCategoryDescriptor</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="getflows-setflowdescriptor-2">getFlows() : Set&lt;FlowDescriptor&gt;</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="getimpacts-setimpactcategorydescriptor-2">getImpacts() : Set&lt;ImpactCategoryDescriptor&gt;</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="getprocesses-setcategorizeddescriptor-2">getProcesses() : Set&lt;CategorizedDescriptor&gt;</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="getresult-contributionresult">getResult() : ContributionResult</h3>
<p><em>Parameters:</em></p>
<ul>
<li>variant : ProjectVariant</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="gettotalflowresult-double">getTotalFlowResult() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>variant : ProjectVariant</li>
<li>flow : FlowDescriptor</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="gettotalflowresults-listflowresult">getTotalFlowResults() : List&lt;FlowResult&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>variant : ProjectVariant</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="gettotalimpactresult-double">getTotalImpactResult() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>variant : ProjectVariant</li>
<li>impact : ImpactCategoryDescriptor</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="getvariants-setprojectvariant">getVariants() : Set&lt;ProjectVariant&gt;</h3>
<p><em>undocumented</em></p>
<h3 id="hascostresults-boolean-2">hasCostResults() : boolean</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="hasflowresults-boolean-2">hasFlowResults() : boolean</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="hasimpactresults-boolean-2">hasImpactResults() : boolean</h3>
<p><em>Overridden method of supertype.</em></p>
<h3 id="isinput-boolean-5">isInput() : boolean</h3>
<p><em>Parameters:</em></p>
<ul>
<li>flow : FlowDescriptor</li>
</ul>
<p><em>Overridden method of supertype.</em></p>
<h2 id="simpleresult-baseresult">SimpleResult &gt; BaseResult</h2>
<p>The simplest kind of result of a calculated product system. This result type is particularly suitable for Monte Carlo simulations or other quick calculations.</p>
<h3 id="scalingvector-double">scalingVector : double[]</h3>
<p>The scaling vector <span class="math inline">\mathbf{s}</span> which is calculated by solving the equation</p>
<p><span class="math display">\mathbf{A} \ \mathbf{s} = \mathbf{f}</span></p>
<p>where <span class="math inline">\mathbf{A}</span> is the technology matrix and <span class="math inline">\mathbf{f}</span> the final demand vector of the product system.</p>
<h3 id="totalcosts-double">totalCosts : double</h3>
<p>The total net-costs <span class="math inline">k_t</span> of the LCC result:</p>
<p><span class="math display">k_t = \mathbf{k} \cdot \mathbf{s}</span></p>
<p>Where <span class="math inline">\mathbf{k}_j</span> are the net-costs of process <span class="math inline">j</span> and <span class="math inline">\mathbf{s}_j</span> is the scaling factor of that process.</p>
<h3 id="totalflowresults-double">totalFlowResults : double[]</h3>
<p>The inventory result <span class="math inline">\mathbf{g}</span> of a product system:</p>
<p><span class="math display">\mathbf{g} = \mathbf{B} \ \mathbf{s}</span></p>
<p>Where <span class="math inline">\mathbf{B}</span> is the intervention matrix and <span class="math inline">\mathbf{s}</span> the scaling vector. Note that inputs have negative values in this vector.</p>
<h3 id="totalimpactresults-double">totalImpactResults : double[]</h3>
<p>The LCIA result <span class="math inline">\mathbf{h}</span> of a product system:</p>
<p><span class="math display">\mathbf{h} = \mathbf{C} \ \mathbf{g}</span></p>
<p>Where <span class="math inline">\mathbf{C}</span> is a flow * LCIA category matrix with the characterization factors and <span class="math inline">\mathbf{g}</span> the inventory result.</p>
<h3 id="totalrequirements-double">totalRequirements : double[]</h3>
<p>The total requirements of the products to fulfill the demand of the product system. As our technology matrix <span class="math inline">\mathbf{A}</span> is indexed symmetrically (means rows and columns refer to the same process-product pair) our product amounts are on the diagonal of the technology matrix <span class="math inline">\mathbf{A}</span> and the total requirements can be calculated by the following equation where <span class="math inline">\mathbf{s}</span> is the scaling vector (<span class="math inline">\odot</span> denotes element-wise multiplication):</p>
<p><span class="math display">\mathbf{t} = \text{diag}(\mathbf{A}) \odot \mathbf{s}</span></p>
<h3 id="getscalingfactor-double">getScalingFactor() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>product : ProcessProduct</li>
</ul>
<p>Get the scaling factor <span class="math inline">\mathbf{s}_j</span> of the given process-product pair <span class="math inline">j</span>.</p>
<h3 id="getscalingfactor-double-1">getScalingFactor() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>process : CategorizedDescriptor</li>
</ul>
<p>Get the scaling factor <span class="math inline">\mathbf{s}_j</span> of the given process <span class="math inline">j</span>. When the process has multiple products in the system it returns the sum of the scaling factors of all of these process-product pairs.</p>
<h3 id="gettotalflowresult-double-1">getTotalFlowResult() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>flow : FlowDescriptor</li>
</ul>
<p>Get the total inventory result <span class="math inline">\mathbf{g}_i</span> of the given flow <span class="math inline">i</span>.</p>
<h3 id="gettotalflowresults-listflowresult-1">getTotalFlowResults() : List&lt;FlowResult&gt;</h3>
<p>Returns the flow results of the inventory result <span class="math inline">\mathbf{g}</span>.</p>
<h3 id="gettotalimpactresult-double-1">getTotalImpactResult() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>impact : ImpactCategoryDescriptor</li>
</ul>
<p>Returns the total LCIA result <span class="math inline">\mathbf{h}_i</span> of the given LCIA category <span class="math inline">i</span>.</p>
<h3 id="gettotalimpactresults-listimpactresult">getTotalImpactResults() : List&lt;ImpactResult&gt;</h3>
<p>Returns the impact category results for the given result.</p>
<h3 id="hascostresults-boolean-3">hasCostResults() : boolean</h3>
<p><em>Overridden method of supertype.</em></p>
<h2 id="simulationresult-baseresult">SimulationResult &gt; BaseResult</h2>
<p>The results of a Monte-Carlo-Simulation. The single result values of the simulation runs are stored in an array of lists where the flow- and LCIA category indices are mapped to the respective array rows and the result values to the respective list entries.</p>
<h3 id="simulationresult">SimulationResult()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>data : MatrixData</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="append-void">append() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>r : SimpleResult</li>
</ul>
<p>Append the total LCI and LCIA result vectors of the given result to this simulation result.</p>
<h3 id="append-void-1">append() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>product : ProcessProduct</li>
<li>direct : SimpleResult</li>
<li>upstream : SimpleResult</li>
</ul>
<p>Append the given direct and upstream result of the pinned product to this result. We only append the respective vectors from the results. The indices of these vectors need to match with the indices of this result.</p>
<h3 id="get-double-8">get() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>flow : FlowDescriptor</li>
<li>i : int</li>
</ul>
<p>Get the result of the given flow in the iteration i (zero based).</p>
<h3 id="get-double-9">get() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>impact : ImpactCategoryDescriptor</li>
<li>i : int</li>
</ul>
<p>Get the result of the given LCIA category in the iteration i (zero based).</p>
<h3 id="getall-double">getAll() : double[]</h3>
<p><em>Parameters:</em></p>
<ul>
<li>flow : FlowDescriptor</li>
</ul>
<p>Get all simulation results of the given flow.</p>
<h3 id="getall-double-1">getAll() : double[]</h3>
<p><em>Parameters:</em></p>
<ul>
<li>impact : ImpactCategoryDescriptor</li>
</ul>
<p>Get all simulation results of the given LCIA category.</p>
<h3 id="getalldirect-double">getAllDirect() : double[]</h3>
<p><em>Parameters:</em></p>
<ul>
<li>product : ProcessProduct</li>
<li>flow : FlowDescriptor</li>
</ul>
<p>Get the direct contribution of the given product to the given flow for all iterations.</p>
<h3 id="getalldirect-double-1">getAllDirect() : double[]</h3>
<p><em>Parameters:</em></p>
<ul>
<li>product : ProcessProduct</li>
<li>impact : ImpactCategoryDescriptor</li>
</ul>
<p>Get the direct contribution of the given product to the given LCIA category for all iterations.</p>
<h3 id="getallupstream-double">getAllUpstream() : double[]</h3>
<p><em>Parameters:</em></p>
<ul>
<li>product : ProcessProduct</li>
<li>flow : FlowDescriptor</li>
</ul>
<p>Get the upstream contribution of the given product to the given flow for all iterations.</p>
<h3 id="getallupstream-double-1">getAllUpstream() : double[]</h3>
<p><em>Parameters:</em></p>
<ul>
<li>product : ProcessProduct</li>
<li>impact : ImpactCategoryDescriptor</li>
</ul>
<p>Get the upstream contribution of the given product to the given LCIA category for all iterations.</p>
<h3 id="getdirect-double">getDirect() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>product : ProcessProduct</li>
<li>flow : FlowDescriptor</li>
<li>i : int</li>
</ul>
<p>Get the direct contribution of the given product to the given flow in the iteration i (zero based).</p>
<h3 id="getdirect-double-1">getDirect() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>product : ProcessProduct</li>
<li>impact : ImpactCategoryDescriptor</li>
<li>i : int</li>
</ul>
<p>Get the direct contribution of the given product to the given LCIA category in the iteration i (zero based).</p>
<h3 id="getnumberofruns-int">getNumberOfRuns() : int</h3>
<p><em>undocumented</em></p>
<h3 id="getpinnedproducts-setprocessproduct">getPinnedProducts() : Set&lt;ProcessProduct&gt;</h3>
<p><em>undocumented</em></p>
<h3 id="getupstream-double">getUpstream() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>product : ProcessProduct</li>
<li>flow : FlowDescriptor</li>
<li>i : int</li>
</ul>
<p>Get the upstream contribution of the given product to the given flow in the iteration i (zero based).</p>
<h3 id="getupstream-double-1">getUpstream() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>product : ProcessProduct</li>
<li>impact : ImpactCategoryDescriptor</li>
<li>i : int</li>
</ul>
<p>Get the upstream contribution of the given product to the given LCIA category in the iteration i (zero based).</p>
<h3 id="hascostresults-boolean-4">hasCostResults() : boolean</h3>
<p><em>Overridden method of supertype.</em></p>
<h2 id="statistics">Statistics</h2>
<p>Calculates statistic parameters for a set of numbers. This is mainly used for presenting results of a Monte-Carlo-Simulation.</p>
<h3 id="count-int">count : int</h3>
<p><em>undocumented</em></p>
<h3 id="max-double">max : double</h3>
<p><em>undocumented</em></p>
<h3 id="mean-double">mean : double</h3>
<p><em>undocumented</em></p>
<h3 id="median-double">median : double</h3>
<p><em>undocumented</em></p>
<h3 id="min-double">min : double</h3>
<p><em>undocumented</em></p>
<h3 id="range-double">range : double</h3>
<p><em>undocumented</em></p>
<h3 id="standarddeviation-double">standardDeviation : double</h3>
<p><em>undocumented</em></p>
<h3 id="empty-statistics">empty() : Statistics</h3>
<p><em>undocumented</em></p>
<h3 id="getpercentilevalue-double">getPercentileValue() : double</h3>
<p><em>Parameters:</em></p>
<ul>
<li>percentile : int</li>
</ul>
<p>Returns the value at the given percentile.</p>
<p><span class="citation" data-cites="param">@param</span> percentile the percentage value (0..100)</p>
<h3 id="hist-histogram">hist() : Histogram</h3>
<p><em>Parameters:</em></p>
<ul>
<li>values : double[]</li>
<li>intervalCount : int</li>
</ul>
<p>Creates a histogram with associated statistics for the given data and number of intervals.</p>
<h3 id="of-statistics">of() : Statistics</h3>
<p><em>Parameters:</em></p>
<ul>
<li>vals : double[]</li>
</ul>
<p><em>undocumented</em></p>
<h2 id="upstreamnode">UpstreamNode</h2>
<p>Describes a node in an upstream tree.</p>
<h3 id="provider-processproduct">provider : ProcessProduct</h3>
<p>A process-flow pair which is a product output or waste input that describes a process in the upstream result tree.</p>
<h3 id="result-double">result : double</h3>
<p>The upstream result of this node.</p>
<h2 id="upstreamtree">UpstreamTree</h2>
<p>Maps the upstream results of the product system graph to a tree where the root is the reference process of the product system.</p>
<h3 id="upstreamtree-1">UpstreamTree()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>r : FullResult</li>
<li>u : double[]</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="upstreamtree-2">UpstreamTree()</h3>
<p><em>Parameters:</em></p>
<ul>
<li>ref : BaseDescriptor</li>
<li>r : FullResult</li>
<li>u : double[]</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="ref-basedescriptor">ref : BaseDescriptor</h3>
<p>An optional reference to a model (e.g. flow or LCIA category) to which the upstream tree is related.</p>
<h3 id="root-upstreamnode">root : UpstreamNode</h3>
<p><em>undocumented</em></p>
<h3 id="childs-listupstreamnode">childs() : List&lt;UpstreamNode&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>parent : UpstreamNode</li>
</ul>
<p><em>undocumented</em></p>
<h1 id="package-org.openlca.eigen">Package: org.openlca.eigen</h1>
<h2 id="nativelibrary">NativeLibrary</h2>
<p>A helper class for loading the native library from a file directory.</p>
<h3 id="isloaded-boolean">isLoaded() : boolean</h3>
<p><em>undocumented</em></p>
<h3 id="loadfromdir-void">loadFromDir() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>dir : File</li>
</ul>
<p><em>undocumented</em></p>
<h1 id="package-org.openlca.julia">Package: org.openlca.julia</h1>
<h2 id="julia">Julia</h2>
<p>Provides the Java interface for the native Julia libraries and contains some utility methods for loading these libraries.</p>
<h3 id="invert-int">invert() : int</h3>
<p><em>Parameters:</em></p>
<ul>
<li>n : int</li>
<li>a : double[]</li>
</ul>
<p>Inverts the given matrix.</p>
<p><span class="citation" data-cites="param">@param</span> n [in] the dimension of the matrix (n = rows = columns) <span class="citation" data-cites="param">@param</span> a [io] on entry: the matrix to be inverted, on exit: the inverse (size = n * n) <span class="citation" data-cites="return">@return</span> the LAPACK return code</p>
<h3 id="isloaded-boolean-1">isLoaded() : boolean</h3>
<p>Returns true if the Julia libraries with openLCA bindings are loaded.</p>
<h3 id="iswithumfpack-boolean">isWithUmfpack() : boolean</h3>
<p><em>undocumented</em></p>
<h3 id="load-boolean">load() : boolean</h3>
<p>Loads the libraries from a folder specified by the “OLCA_JULIA” environment variable.</p>
<h3 id="loadfromdir-boolean">loadFromDir() : boolean</h3>
<p><em>Parameters:</em></p>
<ul>
<li>dir : File</li>
</ul>
<p>Loads the Julia libraries and openLCA bindings from the given folder. Returns true if the libraries could be loaded (at least there should be a <code>libjolca</code> library in the folder that could be loaded).</p>
<h3 id="mmult-void">mmult() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>rowsA : int</li>
<li>colsB : int</li>
<li>k : int</li>
<li>a : double[]</li>
<li>b : double[]</li>
<li>c : double[]</li>
</ul>
<p>Matrix-matrix multiplication: C := A * B</p>
<p><span class="citation" data-cites="param">@param</span> rowsA [in] number of rows of matrix A <span class="citation" data-cites="param">@param</span> colsB [in] number of columns of matrix B <span class="citation" data-cites="param">@param</span> k [in] number of columns of matrix A and number of rows of matrix B <span class="citation" data-cites="param">@param</span> a [in] matrix A (size = rowsA<em>k) <span class="citation" data-cites="param">@param</span> b [in] matrix B (size = k </em> colsB) <span class="citation" data-cites="param">@param</span> c [out] matrix C (size = rowsA * colsB)</p>
<h3 id="mvmult-void">mvmult() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>rowsA : int</li>
<li>colsA : int</li>
<li>a : double[]</li>
<li>x : double[]</li>
<li>y : double[]</li>
</ul>
<p>Matrix-vector multiplication: y:= A * x</p>
<p><span class="citation" data-cites="param">@param</span> rowsA [in] rows of matrix A <span class="citation" data-cites="param">@param</span> colsA [in] columns of matrix A <span class="citation" data-cites="param">@param</span> a [in] the matrix A <span class="citation" data-cites="param">@param</span> x [in] the vector x <span class="citation" data-cites="param">@param</span> y [out] the resulting vector y</p>
<h3 id="solve-int">solve() : int</h3>
<p><em>Parameters:</em></p>
<ul>
<li>n : int</li>
<li>nrhs : int</li>
<li>a : double[]</li>
<li>b : double[]</li>
</ul>
<p>Solves a system of linear equations A * X = B for general matrices. It calls the LAPACK DGESV routine.</p>
<p><span class="citation" data-cites="param">@param</span> n [in] the dimension of the matrix A (n = rows = columns of A) <span class="citation" data-cites="param">@param</span> nrhs [in] the number of columns of the matrix B <span class="citation" data-cites="param">@param</span> a [io] on entry the matrix A, on exit the LU factorization of A (size = n * n) <span class="citation" data-cites="param">@param</span> b [io] on entry the matrix B, on exit the solution of the equation (size = n * bColums) <span class="citation" data-cites="return">@return</span> the LAPACK return code</p>
<h3 id="umfdispose-void">umfDispose() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>pointer : long</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="umffactorize-long">umfFactorize() : long</h3>
<p><em>Parameters:</em></p>
<ul>
<li>n : int</li>
<li>columnPointers : int[]</li>
<li>rowIndices : int[]</li>
<li>values : double[]</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="umfsolve-void">umfSolve() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>n : int</li>
<li>columnPointers : int[]</li>
<li>rowIndices : int[]</li>
<li>values : double[]</li>
<li>demand : double[]</li>
<li>result : double[]</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="umfsolvefactorized-long">umfSolveFactorized() : long</h3>
<p><em>Parameters:</em></p>
<ul>
<li>pointer : long</li>
<li>demand : double[]</li>
<li>result : double[]</li>
</ul>
<p><em>undocumented</em></p>
<h1 id="package-org.openlca.util">Package: org.openlca.util</h1>
<h2 id="categories">Categories</h2>
<p>Utility functions for openLCA categories.</p>
<h3 id="createrefid-string">createRefId() : String</h3>
<p><em>Parameters:</em></p>
<ul>
<li>category : Category</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="path-liststring">path() : List&lt;String&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>category : Category</li>
</ul>
<p><em>undocumented</em></p>
<h2 id="dirs">Dirs</h2>
<p>A simple utility class for directory operations.</p>
<h3 id="clean-void">clean() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>dir : Path</li>
</ul>
<p>Deletes the content from the given directory but not the directory itself.</p>
<h3 id="copy-void">copy() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>from : Path</li>
<li>to : Path</li>
</ul>
<p>Copies a directory recursively.</p>
<h3 id="delete-void">delete() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>path : String</li>
</ul>
<p>Deletes a directory recursively.</p>
<h3 id="delete-void-1">delete() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>dir : Path</li>
</ul>
<p>Deletes a directory recursively.</p>
<h3 id="make-void">make() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>path : String</li>
</ul>
<p>Creates a directory if it not yet exists.</p>
<h3 id="make-void-1">make() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>dir : Path</li>
</ul>
<p>Creates a directory if it not yet exists.</p>
<h3 id="move-void">move() : void</h3>
<p><em>Parameters:</em></p>
<ul>
<li>from : Path</li>
<li>to : Path</li>
</ul>
<p>Moves the given directory to the new location.</p>
<h3 id="size-long">size() : long</h3>
<p><em>Parameters:</em></p>
<ul>
<li>dir : Path</li>
</ul>
<p>Determines the size of the content of a directory recursively.</p>
<h2 id="keygen">KeyGen</h2>
<p>Generates a UUID version 3 for a given set of names.</p>
<p>Note that the generated key is case insensitive and that leading and trailing white-spaces are ignored.</p>
<h3 id="null_uuid-string">NULL_UUID : String</h3>
<p><em>undocumented</em></p>
<h3 id="get-string">get() : String</h3>
<p><em>Parameters:</em></p>
<ul>
<li>names : String</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="topath-string">toPath() : String</h3>
<p><em>Parameters:</em></p>
<ul>
<li>names : String</li>
</ul>
<p><em>undocumented</em></p>
<h2 id="os">OS</h2>
<p>Constants for some operating systems which are retrieved from the system property “os.name”.</p>
<h3 id="linux">LINUX</h3>
<p><em>undocumented</em></p>
<h3 id="mac">MAC</h3>
<p><em>undocumented</em></p>
<h3 id="windows">WINDOWS</h3>
<p><em>undocumented</em></p>
<h3 id="other">OTHER</h3>
<p><em>undocumented</em></p>
<h3 id="get-os">get() : OS</h3>
<p><em>undocumented</em></p>
<h3 id="gettempdir-file">getTempDir() : File</h3>
<p><em>undocumented</em></p>
<h3 id="tostring-string-9">toString() : String</h3>
<p><em>Overridden method of supertype.</em></p>
<h2 id="refidmap">RefIdMap</h2>
<p>In the imports and exports we often need a mapping of reference IDs to database internal IDs or the other way around. This class exactly provides such mappings by caching all IDs from the database.</p>
<h3 id="get-to">get() : To</h3>
<p><em>Parameters:</em></p>
<ul>
<li>type : Class&lt;?&gt;</li>
<li>id : From</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="internaltoref-refidmaplong-string">internalToRef() : RefIdMap&lt;Long, String&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>db : IDatabase</li>
<li>types : Class&lt;? extends T&gt;</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="reftointernal-refidmapstring-long">refToInternal() : RefIdMap&lt;String, Long&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>db : IDatabase</li>
<li>types : Class&lt;? extends T&gt;</li>
</ul>
<p><em>undocumented</em></p>
<h2 id="strings">Strings</h2>
<p>Contains helper methods for string operations.</p>
<h3 id="append-string">append() : String[]</h3>
<p><em>Parameters:</em></p>
<ul>
<li>array : String[]</li>
<li>value : String</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="compare-int">compare() : int</h3>
<p><em>Parameters:</em></p>
<ul>
<li>str1 : String</li>
<li>str2 : String</li>
</ul>
<p>A null-save method for comparing two strings ignoring the case.</p>
<h3 id="cut-string">cut() : String</h3>
<p><em>Parameters:</em></p>
<ul>
<li>string : String</li>
<li>length : int</li>
</ul>
<p>Cut a string to the given length. Appends “…” if the string was truncated.</p>
<h3 id="join-string">join() : String</h3>
<p><em>Parameters:</em></p>
<ul>
<li>values : Collection<T></li>
<li>delimiter : char</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="join-string-1">join() : String</h3>
<p><em>Parameters:</em></p>
<ul>
<li>values : String[]</li>
<li>delimiter : char</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="notempty-boolean">notEmpty() : boolean</h3>
<p><em>Parameters:</em></p>
<ul>
<li>val : String</li>
</ul>
<p>Returns true if the string is not null or empty, means that it contains other characters that white-spaces.</p>
<h3 id="nullorempty-boolean">nullOrEmpty() : boolean</h3>
<p><em>Parameters:</em></p>
<ul>
<li>val : String</li>
</ul>
<p>Returns true if the given string value is null or empty.</p>
<h3 id="nullorequal-boolean">nullOrEqual() : boolean</h3>
<p><em>Parameters:</em></p>
<ul>
<li>string1 : String</li>
<li>string2 : String</li>
</ul>
<p>Returns true if both of the given strings are null or if both of the given strings are equal.</p>
<h3 id="prepend-string">prepend() : String[]</h3>
<p><em>Parameters:</em></p>
<ul>
<li>array : String[]</li>
<li>value : String</li>
</ul>
<p><em>undocumented</em></p>
<h3 id="readlines-string">readLines() : String[]</h3>
<p><em>Parameters:</em></p>
<ul>
<li>is : InputStream</li>
</ul>
<p><em>undocumented</em></p>
<h2 id="toposort">TopoSort</h2>
<p>An implementation of Kahn’s algorithm for topological sorting.</p>
<h3 id="of-listlong">of() : List&lt;Long&gt;</h3>
<p><em>Parameters:</em></p>
<ul>
<li>pairs : Iterable<LongPair></li>
</ul>
<p>Creates a topological order of the given relations. Each relation is encoded in a pair of IDs <code>(first, second)</code> where the (element with the) <code>second</code> ID depends on the (element with the) <code>first</code> ID. The IDs are returned in a list with increasing dependency order. As a topological order can be only created on relations that form an acyclic graph, the first element of the returned list has no dependencies. When there are cycles in the relations, this method returns <code>null</code> which means that a topological order cannot be created.</p>
</body>
</html>
